<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Puzzle Decrypter Playground</title>
  <style>
    :root{
      --bg:#020617;
      --panel:#0f172a;
      --muted:#94a3b8;
      --ink:#f8fafc;
      --accent:#38bdf8;
      --accent-soft:rgba(56,189,248,0.18);
      --input-bg:#0b1220;
      --input-ink:#f8fafc;
      --input-bd:#1e293b;
      --hot:#f97316;
      --cold:#38bdf8;
      font-family:'Nunito', 'Inter', system-ui, -apple-system, 'Segoe UI', sans-serif;
    }
    .thinking-panel {
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      min-height:110px;
    }
    .thinking-text {
      font-size:22px;
      font-weight:800;
      letter-spacing:0.12em;
      text-transform:uppercase;
      color:var(--accent);
      text-shadow:0 0 26px rgba(56,189,248,0.35);
    }
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top left, #172554 0%, #020617 55%, #01030f 100%);
      color: var(--ink);
      padding: 32px 18px 54px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 { font-size: 28px; margin:0 0 8px; font-weight:800; letter-spacing:-0.01em }
    h2 { font-size: 18px; margin:0 0 12px; font-weight:700 }
    p { margin:0 }
    .hero {
      width: min(960px, 100%);
      margin: 0 auto 24px;
      text-align: center;
    }
    .hero p {
      color: var(--muted);
      font-size: 16px;
      line-height: 1.5;
    }
    .panels {
      width: min(1400px, 100%);
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .panel {
      background: var(--panel);
      border-radius: 18px;
      box-shadow: 0 28px 60px rgba(2,6,23,0.55);
      padding: 24px;
      position: relative;
      overflow: hidden;
    }
    .panel::before{
      content:"";
      position:absolute;
      inset:-120px -120px auto auto;
      width:220px;height:220px;
      background:var(--accent-soft);
      border-radius:50%;
      filter:blur(0px);
      opacity:.4;
      pointer-events:none;
    }
    textarea {
      width:100%;
      min-height:120px;
      font-family: 'Fira Code', monospace;
      font-size:15px;
      padding:16px;
      border-radius:14px;
      background:var(--input-bg);
      color:var(--input-ink);
      border:2px solid var(--input-bd);
      transition:border-color .2s ease, box-shadow .2s ease;
      box-shadow:0 12px 26px rgba(8,17,35,0.65);
    }
    textarea:focus {
      outline:none;
      border-color:var(--accent);
      box-shadow:0 14px 34px rgba(56,189,248,0.35);
    }
    .grid {
      display:flex;
      gap:14px 12px;
      flex-wrap:wrap;
      margin-top:16px;
      padding:18px;
      border-radius:16px;
      background:linear-gradient(145deg, rgba(56,189,248,0.08), rgba(15,118,110,0.08));
      border:1px solid rgba(148,163,184,0.12);
      align-items:flex-start;
    }
    .word {
      display:flex;
      flex-wrap:nowrap;
      flex:0 0 auto;
      gap:8px;
    }
    .word-gap {
      flex:0 0 26px;
      height:1px;
      pointer-events:none;
    }
    .line-break {
      flex-basis:100%;
      height:0;
      pointer-events:none;
    }
    .cell {
      width:38px;
      text-align:center;
      position:relative;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
    }
    .char {
      display:block;
      padding:8px 0;
      background:#1e293b;
      border-radius:12px;
      font-weight:700;
      border:2px solid transparent;
      width:100%;
      box-sizing:border-box;
      color:var(--accent);
      box-shadow:0 10px 22px rgba(2,6,23,0.55);
    }
    .cell.selecting { cursor:pointer }
    .cell.selected .char { border-color:var(--accent); }
    input.cribin {
      width:100%;
      text-align:center;
      border-radius:12px;
      padding:10px 0;
      background:#1e293b;
      color:var(--input-ink);
      border:2px solid rgba(56,189,248,0.35);
      font-weight:800;
      box-sizing:border-box;
      font-size:20px;
      min-height:44px;
      transition:border-color .2s ease, box-shadow .2s ease;
      box-shadow:0 10px 24px rgba(8,17,35,0.55);
    }
    input.cribin:focus { outline:none; border-color:var(--accent); box-shadow:0 16px 36px rgba(56,189,248,0.38); }
    input.cribin[disabled]{ opacity:.35; cursor:not-allowed; background:rgba(15,23,42,0.9); box-shadow:none }
    .controls {
      display:flex;
      gap:12px;
      align-items:center;
      margin-top:18px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .controls button {
      padding:12px 22px;
      border-radius:999px;
      border:none;
      font-weight:700;
      cursor:pointer;
      transition:transform .15s ease, box-shadow .2s ease;
      background:var(--accent);
      color:#05132c;
      box-shadow:0 18px 34px rgba(56,189,248,0.28);
    }
    .controls button.secondary {
      background:rgba(15,23,42,0.9);
      color:var(--muted);
      box-shadow:0 12px 28px rgba(2,6,23,0.55);
      border:1px solid rgba(148,163,184,0.18);
    }
    .controls button:hover { transform:translateY(-1px); box-shadow:0 22px 40px rgba(56,189,248,0.35); }
    .controls button.secondary:hover { box-shadow:0 16px 30px rgba(2,6,23,0.7); }
    button:disabled { opacity:.45; cursor:not-allowed; box-shadow:none; transform:none }
    pre {
      background:rgba(15,23,42,0.85);
      padding:18px;
      border-radius:16px;
      overflow:auto;
      white-space:pre-wrap;
      font-size:16px;
      line-height:1.6;
      color:var(--ink);
      box-shadow:inset 0 0 0 1px rgba(56,189,248,0.12);
    }
    .muted { color:var(--muted); }
    .legend { display:none }
    .small { font-size:13px }
    .summary-text {
      font-size:16px;
      line-height:1.6;
      font-weight:600;
      transition:color .2s ease, transform .2s ease;
    }
    .summary-text.no-result {
      color:var(--accent);
      font-size:20px;
      font-weight:800;
      letter-spacing:0.01em;
      text-shadow:0 0 20px rgba(56,189,248,0.35);
    }
    .heat-meter { margin-top:18px; }
    .heat-track {
      position:relative;
      height:20px;
      background:rgba(15,23,42,0.9);
      border:1px solid rgba(56,189,248,0.25);
      border-radius:999px;
      overflow:hidden;
      box-shadow:0 14px 30px rgba(2,6,23,0.65);
    }
    .heat-fill {
      position:absolute;
      top:0;left:0;height:100%;
      width:0%;
      background:linear-gradient(90deg,var(--cold) 0%, #60a5fa 25%, #a855f7 60%, var(--hot) 100%);
      box-shadow:0 0 18px rgba(249,115,22,0.45);
      transition:width .35s ease, box-shadow .35s ease;
    }
    .heat-labels {
      margin-top:6px;
      display:flex;
      justify-content:space-between;
      font-weight:600;
      color:var(--muted);
    }
    .stat-chips {
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      margin-top:14px;
    }
    .chip {
      background:rgba(8,17,35,0.85);
      color:var(--muted);
      padding:8px 14px;
      border-radius:999px;
      font-weight:700;
      font-size:13px;
      border:1px solid rgba(56,189,248,0.18);
    }
    .hidden-control { display:none !important; }
    #progressPanel { display:none; }
    #progressLabel { font-weight:800; font-size:22px; letter-spacing:0.12em; text-transform:uppercase; color:var(--accent); text-shadow:0 0 26px rgba(56,189,248,0.35); }

    .confetti-container {
      position:fixed;
      inset:0;
      pointer-events:none;
      overflow:hidden;
      z-index:9999;
    }
    .confetti-piece {
      position:absolute;
      top:-12vh;
      width:8px;
      height:18px;
      border-radius:3px;
      opacity:0;
      transform:translate3d(0,-120vh,0) rotate(0deg);
      animation:confettiFall 2.2s ease-in forwards;
    }
    @keyframes confettiFall {
      0% { opacity:0; transform:translate3d(0,-120vh,0) rotate(0deg); }
      10% { opacity:1; }
      100% { opacity:0; transform:translate3d(var(--confetti-x, 0px), 120vh, 0) rotate(360deg); }
    }
    @media (max-width: 720px) {
      body { padding:24px 16px; }
      .hero { width:100%; }
      .panel { padding:20px; }
      .grid { justify-content:center; }
      .cell { width:44px; }
      textarea { min-height:140px; }
    }

    @media (max-width: 480px) {
      .controls { justify-content:center; }
      .controls button { flex:1 1 100%; max-width:280px; }
      textarea { min-height:160px; }
    }

    @media (min-width: 1100px) {
      body { padding:48px 48px 72px; }
      .hero { width:min(1100px, 100%); }
      .panels {
        display:grid;
        grid-template-columns:repeat(12, minmax(0, 1fr));
        gap:22px;
        grid-template-areas:
          "setup setup setup setup results results results results results results results results"
          "grid grid grid grid grid grid grid grid grid grid grid grid"
          "wordlist wordlist wordlist wordlist wordlist wordlist wordlist wordlist wordlist wordlist wordlist wordlist"
          "brute brute brute brute brute brute brute brute brute brute brute brute";
      }
      #setupPanel { grid-area: setup; }
      #results { grid-area: results; }
      #gridPanel { grid-area: grid; }
      #wordlistPanel { grid-area: wordlist; }
      #bruteResults { grid-area: brute; }
    }
  </style>
</head>
<body>
  <header class="hero">
    <h1>Autokey Puzzle Playground</h1>
    <p>Crack a mysterious message by guessing the missing letters. Start by pasting your cipher text, sprinkle in the letters you feel confident about, and let the playground test how close you are to a real English solution.</p>
  </header>

  <div class="panels">
    <section class="panel" id="setupPanel">
      <h2>Step 1 · Drop in your cipher</h2>
      <p class="muted">We keep all punctuation and spacing intact so everything lines up perfectly while you solve.</p>
      <textarea id="ctext">Rc qipv jhx vld plson fhceuh itp jui gh qhzu dg sq xie dhw. U gbfl lf fluz pcag wrgkv zw, dinyg zw, qge gnvm L fhx.</textarea>

      <div class="hidden-control">
        <label class="small muted" for="minK">Key length range:</label>
        <input id="minK" type="number" min="1" value="4" />
        <input id="maxK" type="number" min="1" value="20" />
        <label class="small muted" for="op">Operation:</label>
        <select id="op">
          <option value="vigenere">Vigenère (C = P + K mod26)</option>
          <option value="vig_sub">Vigenère + unknown substitution (pre‑sub on plaintext)</option>
          <option value="vig_sub_post">Vigenère + unknown substitution (post‑sub on ciphertext)</option>
          <option value="vig_custom_alpha">Vigenère with unknown alphabet (shared custom order)</option>
          <option value="autokey_custom_alpha" selected>Autokey with unknown alphabet (shared custom order)</option>
        </select>
        <label id="autokeyAlgoLabel" class="small muted" for="autokeyAlgo">Autokey variant:</label>
        <select id="autokeyAlgo">
          <option value="vigenere">Vigenère-style (C = P + K)</option>
          <option value="beaufort">Beaufort (C = K − P)</option>
          <option value="beaufort_variant">Variant Beaufort (C = P − K)</option>
        </select>
      </div>

      <div class="controls">
        <button id="render" class="secondary">Refresh Puzzle</button>
        <button id="stopSearch" class="secondary" disabled>Stop Thinking</button>
        <button id="test">Test My Guess</button>
      </div>
    </section>

    <section class="panel" id="gridPanel">
      <h2>Step 2 · Fill in what you know</h2>
      <p class="muted">Click under each letter and type your guess. We'll only let you edit the spots that are real letters.</p>
      <div id="grid" class="grid"></div>
    </section>

    <section class="panel" id="results">
      <h2>Step 3 · See how hot your guess is</h2>
      <div id="summary" class="summary-text muted">No test run yet — add a few guesses to start!</div>
      <div class="heat-meter">
        <div class="heat-track">
          <div id="heatFill" class="heat-fill" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"></div>
        </div>
        <div class="heat-labels"><span>Cold</span><span>Hot!</span></div>
      </div>
      <div class="stat-chips">
        <div class="chip" id="chiStat">χ²: —</div>
        <div class="chip" id="iocStat">IOC: —</div>
      </div>
      <pre id="out"></pre>
    </section>

    <section class="panel hidden-control" id="wordlistPanel">
      <h2>Wordlist Brute Force</h2>
      <div class="small muted">Upload a wordlist and try all words at a selected position to find the best crib candidates.</div>
      <div class="row" style="margin-top:10px">
        <input type="file" id="wordlistFile" accept=".txt" />
        <button id="selectMode">Select Word Position</button>
        <label class="small muted">Max results:</label>
        <input id="maxResults" type="number" min="1" value="20" style="width:72px" />
              <label class="small muted">Quick trials:</label>
        <input id="quickTrialsInput" type="number" min="0" value="30" style="width:72px" />
        <label class="small muted">Trial depth:</label>
        <input id="trialDepthInput" type="number" min="0" value="3" style="width:72px" />
        <label class="small muted">Word timeout (ms):</label>
        <input id="wordTimeoutInput" type="number" min="0" value="1500" style="width:90px" />
        <label class="checkbox-row small" style="padding:0 6px 0 0">
          <input type="checkbox" id="bruteBridgeNext" /> Enforce next crib
        </label>
        <button id="bruteForce">Brute force cribs</button>
      </div>
      <div id="wordlistStatus" class="small muted" style="margin-top:8px">No wordlist loaded</div>
      <div id="selectionInfo" class="selection-info small">
        <strong>Selection:</strong> <span id="selectionText">None</span> |
        <strong>Position:</strong> <span id="selectionPos">-</span> |
        <strong>Length:</strong> <span id="selectionLen">-</span>
      </div>
    </section>

    <section class="panel hidden-control" id="bruteResults" style="display:none">
      <h2>Brute Force Results</h2>
      <div id="bruteSummary" class="small muted"></div>
      <div id="bruteOut"></div>
    </section>
  </div>

<script>
// ===== Core helpers =====
const A = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
const A2I = {}; for (let i=0;i<26;i++) A2I[A[i]] = i;
const isLetter = ch => /[A-Za-z]/.test(ch);
const sanitize = s => s.toUpperCase().replace(/[^A-Z]/g,'');

let wordlist = [];

const CONFETTI_COLORS = ['#38bdf8', '#f97316', '#a855f7', '#22d3ee', '#facc15'];
const THINKING_STATES = ['.', '..', '...'];
let confettiCooling = false;
let lastHeatScore = 0;
let thinkingInterval = null;
let thinkingIndex = 0;

function triggerConfetti(){
  if (confettiCooling) return;
  confettiCooling = true;
  const container = document.createElement('div');
  container.className = 'confetti-container';
  const pieceCount = 110;
  for (let i = 0; i < pieceCount; i++){
    const piece = document.createElement('span');
    piece.className = 'confetti-piece';
    piece.style.background = CONFETTI_COLORS[i % CONFETTI_COLORS.length];
    piece.style.left = `${Math.random() * 100}%`;
    piece.style.width = `${5 + Math.random() * 6}px`;
    piece.style.height = `${10 + Math.random() * 12}px`;
    piece.style.animationDelay = `${Math.random() * 0.6}s`;
    piece.style.animationDuration = `${1.6 + Math.random() * 0.9}s`;
    piece.style.transform = `rotate(${Math.random() * 360}deg)`;
    piece.style.setProperty('--confetti-x', `${(Math.random() * 220) - 110}px`);
    container.appendChild(piece);
  }
  document.body.appendChild(container);
  setTimeout(() => {
    container.remove();
  }, 2300);
  setTimeout(() => {
    confettiCooling = false;
  }, 1200);
}

function updateThinkingLabel(){
  const label = document.getElementById('progressLabel');
  const panel = document.getElementById('progressPanel');
  if (!label || !panel) return;
  const base = panel.dataset.baseLabel || 'Thinking';
  const suffix = THINKING_STATES[thinkingIndex % THINKING_STATES.length];
  label.textContent = `${base}${suffix}`;
}

function restartThinkingAnimation(baseLabel){
  const panel = ensureProgressPanel();
  panel.dataset.baseLabel = baseLabel || 'Thinking';
  thinkingIndex = 0;
  updateThinkingLabel();
  if (thinkingInterval){
    clearInterval(thinkingInterval);
  }
  thinkingInterval = setInterval(() => {
    thinkingIndex = (thinkingIndex + 1) % THINKING_STATES.length;
    updateThinkingLabel();
  }, 520);
}

function stopThinkingAnimation(){
  if (thinkingInterval){
    clearInterval(thinkingInterval);
    thinkingInterval = null;
  }
}

const NO_RESULT_MESSAGES = [
  "That wasn't it! The cipher sprites are asking for another guess.",
  "Mystery still locked — add a few fresh crib letters and try again!",
  "Close, but the parchment stays secret. Shuffle your guesses and rerun the test.",
  "The heat meter stayed frosty. Give the puzzle a different sprinkle of clues."
];

function setSummaryMessage(text, options){
  const summary = document.getElementById('summary');
  if (!summary) return;
  summary.textContent = text;
  const opts = options || {};
  const isNoResult = !!opts.noResult;
  summary.classList.toggle('no-result', isNoResult);
  if (isNoResult){
    summary.classList.remove('muted');
  } else {
    summary.classList.add('muted');
  }
}

function getQuickTrials(){
  const el = document.getElementById('quickTrialsInput');
  if (!el) return 30;
  const v = parseInt(el.value, 10);
  if (Number.isFinite(v) && v >= 0) return v;
  return 30;
}

function getTrialDepth(){
  const el = document.getElementById('trialDepthInput');
  if (!el) return 3;
  const v = parseInt(el.value,10);
  if (Number.isFinite(v) && v >= 0) return v;
  return 3;
}

function getWordTimeoutMs(){
  const el = document.getElementById('wordTimeoutInput');
  if (!el) return 0;
  const v = parseInt(el.value, 10);
  if (Number.isFinite(v) && v >= 0) return v;
  return 0;
}
let selectionMode = false;
let selectionStart = -1;
let selectionEnd = -1;

// Scoring: chi-square + substring hits (normalized per 100 letters)
const FREQ = {'E':12.0,'T':9.1,'A':8.2,'O':7.5,'I':7.0,'N':6.7,'S':6.3,'R':6.0,'H':6.1,'L':4.0,'D':4.3,'C':2.8,'U':2.8,'M':2.4,'F':2.2,'Y':2.0,'W':2.4,'G':2.0,'P':1.9,'B':1.5,'V':1.0,'K':0.8,'X':0.2,'Q':0.1,'J':0.15,'Z':0.07};
function chiScore(up){
  const n = up.length; if (!n) return 0;
  const cnt = {}; for (const ch of up){ cnt[ch]=(cnt[ch]||0)+1; }
  let chi = 0;
  for (const ch of A){ const obs=(cnt[ch]||0); const exp=FREQ[ch]*n/100; if (exp>0) chi += (obs-exp)*(obs-exp)/exp; }
  return -chi;
}
function wordHits(upStr){
  const COMMON_SUBS = ['THE','AND','ING','ION','ENT','THAT','ERE','HER','HAT','HIS','VER','TER','EST','FOR','YOU','HAVE','WITH','ARE','NOT'];
  let hits=0; const S = upStr;
  for (const w of COMMON_SUBS){
    let pos=0; while (true){ const i=S.indexOf(w,pos); if (i===-1) break; hits++; pos=i+1; }
  }
  return hits;
}
function englishFitness(upArr){
  const n = upArr.length || 1;
  const s = upArr.join('');
  const chi = chiScore(upArr);
  const subs = wordHits(s);
  const raw = chi + 4*subs;
  return (raw / n) * 100;
}

function computeEnglishStats(text){
  const clean = sanitize(text || '');
  const counts = {};
  for (const ch of clean){ counts[ch] = (counts[ch] || 0) + 1; }
  const n = clean.length;
  let chi = 0;
  let ic = 0;
  if (n > 1){
    for (const ch of A){
      const obs = counts[ch] || 0;
      const exp = FREQ[ch] * n / 100;
      if (exp > 0){
        const diff = obs - exp;
        chi += (diff * diff) / exp;
      }
      ic += obs * (obs - 1);
    }
    ic /= (n * (n - 1));
  } else if (n === 1){
    ic = 0;
  }
  return { chi, ic, length: n, clean };
}

function clamp01(x){
  if (!Number.isFinite(x)) return 0;
  return Math.max(0, Math.min(1, x));
}

function scoreHeat(stats){
  if (!stats || !stats.length){
    return { score: 0, chi: stats ? stats.chi : 0, ic: stats ? stats.ic : 0, length: stats ? stats.length : 0 };
  }
  const chi = Math.max(0, stats.chi || 0);
  const ic = stats.ic || 0;
  const length = stats.length || 0;
  const chiSweetSpot = 20;
  const chiDecay = 45;
  let chiComponent;
  if (chi <= chiSweetSpot){
    chiComponent = 1;
  } else {
    chiComponent = Math.exp(-(chi - chiSweetSpot) / chiDecay);
  }
  chiComponent = clamp01(chiComponent);
  const iocTarget = 0.066;
  const iocTolerance = 0.005;
  const iocComponent = clamp01(Math.exp(-Math.pow(ic - iocTarget, 2) / (2 * iocTolerance * iocTolerance)));
  const lengthConfidence = clamp01(length / 80);
  let baseScore = (chiComponent * 0.6) + (iocComponent * 0.4);
  if (chi <= chiSweetSpot && Math.abs(ic - iocTarget) <= iocTolerance){
    baseScore = 1;
  } else {
    baseScore *= 0.55 + (0.45 * lengthConfidence);
  }
  const score = clamp01(baseScore);
  return { score, chi, ic, length };
}

function updateHeatMeter(stats){
  const heatFill = document.getElementById('heatFill');
  const chiStat = document.getElementById('chiStat');
  const iocStat = document.getElementById('iocStat');
  if (!heatFill || !chiStat || !iocStat){
    return { score: 0, chi: 0, ic: 0 };
  }
  if (!stats || !stats.length){
    lastHeatScore = 0;
    heatFill.style.width = '0%';
    heatFill.style.opacity = '0.35';
    heatFill.style.boxShadow = 'none';
    heatFill.setAttribute('aria-valuenow', '0');
    heatFill.setAttribute('aria-valuemin', '0');
    heatFill.setAttribute('aria-valuemax', '100');
    chiStat.textContent = 'χ²: —';
    iocStat.textContent = 'IOC: —';
    return { score: 0, chi: 0, ic: 0 };
  }
  const scored = scoreHeat(stats);
  const pct = Math.round(scored.score * 100);
  heatFill.style.width = `${pct}%`;
  heatFill.style.opacity = '1';
  const glow = Math.max(12, 12 + pct * 0.2);
  const glowAlpha = Math.min(0.75, 0.25 + pct / 200);
  heatFill.style.boxShadow = pct > 0 ? `0 0 ${glow}px rgba(249,115,22,${glowAlpha.toFixed(2)})` : 'none';
  heatFill.setAttribute('aria-valuenow', String(pct));
  heatFill.setAttribute('aria-valuemin', '0');
  heatFill.setAttribute('aria-valuemax', '100');
  if (pct >= 96 && pct > lastHeatScore){
    triggerConfetti();
  }
  lastHeatScore = pct;
  const chiVal = scored.chi.toFixed(2);
  const iocVal = scored.ic.toFixed(4);
  chiStat.textContent = `χ²: ${chiVal}`;
  iocStat.textContent = `IOC: ${iocVal}`;
  return scored;
}

function resetHeatMeter(){
  updateHeatMeter(null);
  setSummaryMessage('No test run yet — add a few guesses to start!');
}

const AUTOKEY_ALGOS = ['vigenere','beaufort','beaufort_variant'];
function normalizeAutokeyAlgo(value){
  if (value === 'beaufort' || value === 'beaufort_variant') return value;
  return 'vigenere';
}
function autokeyAlgoLabel(algo){
  const norm = normalizeAutokeyAlgo(algo);
  if (norm === 'beaufort') return 'Beaufort';
  if (norm === 'beaufort_variant') return 'Variant Beaufort';
  return 'Vigenère-style';
}
function currentAutokeyAlgo(){
  const sel = document.getElementById('autokeyAlgo');
  return normalizeAutokeyAlgo(sel ? sel.value : 'vigenere');
}
function autokeyOpsFor(algo){
  const norm = normalizeAutokeyAlgo(algo);
  if (norm === 'beaufort'){
    return {
      keyFromPlainCipher: (p, c) => c + p,
      cipherFromPlainKey: (p, k) => k - p,
      plainFromCipherKey: (c, k) => k - c
    };
  }
  if (norm === 'beaufort_variant'){
    return {
      keyFromPlainCipher: (p, c) => p - c,
      cipherFromPlainKey: (p, k) => p - k,
      plainFromCipherKey: (c, k) => c + k
    };
  }
  return {
    keyFromPlainCipher: (p, c) => c - p,
    cipherFromPlainKey: (p, k) => p + k,
    plainFromCipherKey: (c, k) => c - k
  };
}

// ===== Selection mode =====
function updateSelection(){
  const cells = document.querySelectorAll('.cell');
  cells.forEach((cell, idx) => {
    const letterIdx = parseInt(cell.dataset.letterIdx);
    if (letterIdx === -1) return;
    
    if (selectionStart !== -1 && selectionEnd !== -1){
      const start = Math.min(selectionStart, selectionEnd);
      const end = Math.max(selectionStart, selectionEnd);
      if (letterIdx >= start && letterIdx <= end){
        cell.classList.add('selected');
      } else {
        cell.classList.remove('selected');
      }
    } else {
      cell.classList.remove('selected');
    }
  });

  const info = document.getElementById('selectionInfo');
  const textSpan = document.getElementById('selectionText');
  const posSpan = document.getElementById('selectionPos');
  const lenSpan = document.getElementById('selectionLen');

  if (selectionStart !== -1 && selectionEnd !== -1){
    const {letters} = gatherCribs();
    const {cLetters} = buildLetterStreams(letters);
    const start = Math.min(selectionStart, selectionEnd);
    const end = Math.max(selectionStart, selectionEnd);
    const selectedText = cLetters.slice(start, end + 1).join('');
    
    info.classList.add('active');
    textSpan.textContent = selectedText;
    posSpan.textContent = start;
    lenSpan.textContent = selectedText.length;
  } else {
    info.classList.remove('active');
    textSpan.textContent = 'None';
    posSpan.textContent = '-';
    lenSpan.textContent = '-';
  }
}

function toggleSelectionMode(){
  selectionMode = !selectionMode;
  const btn = document.getElementById('selectMode');
  const cells = document.querySelectorAll('.cell');
  
  if (selectionMode){
    btn.classList.add('active');
    btn.textContent = 'Cancel Selection';
    cells.forEach(cell => cell.classList.add('selecting'));
    selectionStart = -1;
    selectionEnd = -1;
    updateSelection();
  } else {
    btn.classList.remove('active');
    btn.textContent = 'Select Word Position';
    cells.forEach(cell => {
      cell.classList.remove('selecting');
      cell.classList.remove('selected');
    });
    document.getElementById('selectionInfo').classList.remove('active');
  }
}

// ===== UI: render grid =====
function renderGrid(){
  const raw = document.getElementById('ctext').value;
  const letters = raw.split('');
  const grid = document.getElementById('grid');
  grid.innerHTML = '';

  let letterIndex = 0;
  let wordWrap = null;

  const flushWord = () => {
    if (wordWrap && wordWrap.childNodes.length){
      grid.appendChild(wordWrap);
    }
    wordWrap = null;
  };

  const focusStep = (start, direction) => {
    let pointer = start + direction;
    while (pointer >= 0 && pointer < letters.length){
      const target = grid.querySelector(`input.cribin[data-pos="${pointer}"]`);
      if (target && !target.disabled){
        target.focus();
        return target;
      }
      pointer += direction;
    }
    return null;
  };

  letters.forEach((ch, idx) => {
    if (ch === '\r'){
      return;
    }

    if (ch === '\n'){
      flushWord();
      const breaker = document.createElement('div');
      breaker.className = 'line-break';
      grid.appendChild(breaker);
      return;
    }

    if (ch === ' '){
      flushWord();
      const spacer = document.createElement('div');
      spacer.className = 'word-gap';
      grid.appendChild(spacer);
      return;
    }

    if (!wordWrap){
      wordWrap = document.createElement('div');
      wordWrap.className = 'word';
    }

    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.absIdx = idx;

    const cspan = document.createElement('span');
    cspan.className = 'char';
    cspan.textContent = ch;

    const crib = document.createElement('input');
    crib.className = 'cribin';
    crib.maxLength = 1;
    crib.dataset.pos = idx;
    crib.placeholder = '';
    crib.title = 'Type a single plaintext letter (or leave blank)';

    if (!isLetter(ch)){
      crib.disabled = true;
      cell.dataset.letterIdx = -1;
    } else {
      cell.dataset.letterIdx = letterIndex;
      letterIndex++;

      // Selection mode click handler
      cell.addEventListener('click', (e) => {
        if (selectionMode){
          e.stopPropagation();

          const clickedIdx = parseInt(cell.dataset.letterIdx);

          if (selectionStart === -1){
            selectionStart = clickedIdx;
            selectionEnd = clickedIdx;
          } else {
            selectionEnd = clickedIdx;
          }

          updateSelection();
        } else if (!crib.disabled) {
          crib.focus();
        }
      });

      crib.addEventListener('input', () => {
        crib.value = sanitize(crib.value);
        if (crib.value.length === 1){
          focusStep(idx, 1);
        }
      });
      crib.addEventListener('keydown', (e) => {
        if ((e.key === 'Backspace' || e.key==='Delete') && !crib.value){
          focusStep(idx, -1);
        } else if (e.key === 'ArrowRight'){
          focusStep(idx, 1);
        } else if (e.key === 'ArrowLeft'){
          focusStep(idx, -1);
        }
      });
    }

    cell.appendChild(cspan);
    cell.appendChild(crib);
    wordWrap.appendChild(cell);
  });

  flushWord();

  const first = grid.querySelector('input.cribin:not([disabled])');
  if (first) first.focus();
}
// ===== Data extraction =====
function gatherCribs(){
  const raw = document.getElementById('ctext').value;
  const letters = raw.split('');
  const inputs = document.querySelectorAll('input.cribin');
  const cribMap = {};
  inputs.forEach(inp => {
    const v = inp.value ? sanitize(inp.value) : '';
    const pos = parseInt(inp.dataset.pos);
    cribMap[pos] = v || null;
  });
  return {letters, cribMap};
}

function cribLetterAt(cribMap, pos){
  if (!cribMap) return null;
  const raw = cribMap[pos];
  if (!raw) return null;
  const up = sanitize(typeof raw === 'string' ? raw : String(raw));
  return up.length ? up[0] : null;
}

function findNextCribSegmentAfter(letters, cribMap, endStep){
  if (!letters || !cribMap) return [];
  const { absToLetterStep } = buildLetterStreams(letters);
  const stepToAbs = [];
  for (let i = 0; i < absToLetterStep.length; i++){
    const step = absToLetterStep[i];
    if (step >= 0){
      stepToAbs[step] = i;
    }
  }
  if (!Array.isArray(stepToAbs) || stepToAbs.length === 0) return [];
  const segment = [];
  for (let step = endStep + 1; step < stepToAbs.length; step++){
    const abs = stepToAbs[step];
    if (abs == null || abs < 0) continue;
    const letter = cribLetterAt(cribMap, abs);
    if (!letter) continue;
    let pos = step;
    while (pos < stepToAbs.length){
      const absIdx = stepToAbs[pos];
      if (absIdx == null || absIdx < 0) break;
      const nextLetter = cribLetterAt(cribMap, absIdx);
      if (!nextLetter) break;
      segment.push({ step: pos, abs: absIdx, letter: nextLetter });
      pos++;
    }
    break;
  }
  return segment;
}

function collectContiguousCribs(letters, cribMap){
  const segments = [];
  const isAZ = ch => /^[A-Za-z]$/.test(ch || '');
  let i = 0;
  while (i < letters.length){
    if (!isLetter(letters[i])){ i++; continue; }
    // start only on positions where cribMap has a LETTER
    if (cribMap[i] && isAZ(cribMap[i])){
      let j = i;
      let cipherSeg = '';
      let plainSeg  = '';
      while (j < letters.length && isLetter(letters[j]) && cribMap[j] && isAZ(cribMap[j])){
        cipherSeg += letters[j];
        plainSeg  += (cribMap[j] + '').toUpperCase();
        j++;
      }
      // sanitize and only keep non-empty aligned segments
      const cSan = sanitize(cipherSeg);
      const pSan = sanitize(plainSeg);
      if (cSan.length > 0 && pSan.length === cSan.length){
        segments.push({ start:i, cipherSeg:cSan, plainSeg:pSan });
      }
      i = j;
    } else {
      i++;
    }
  }
  return segments;
}

function buildLetterStreams(letters){
  const cLetters = [];
  const absToLetterStep = new Array(letters.length).fill(-1);
  let s = 0;
  for (let i=0;i<letters.length;i++){
    if (isLetter(letters[i])){
      absToLetterStep[i] = s;
      cLetters.push(letters[i].toUpperCase());
      s++;
    }
  }
  return { cLetters, absToLetterStep };
}

function alphabetInfoFromPositions(pos){
  const N = 26;
  const posFull = Array.from({ length: N }, (_, idx) => {
    const val = Array.isArray(pos) ? pos[idx] : null;
    return (Number.isInteger(val) && val >= 0 && val < N) ? val : null;
  });
  const taken = new Array(N).fill(false);
  for (let i = 0; i < N; i++){
    const v = posFull[i];
    if (v != null){
      taken[v] = true;
    }
  }
  let next = 0;
  for (let i = 0; i < N; i++){
    if (posFull[i] == null){
      while (next < N && taken[next]) next++;
      if (next < N){
        posFull[i] = next;
        taken[next] = true;
      }
    }
  }
  const inv = new Array(N);
  for (let i = 0; i < N; i++){
    const idx = posFull[i];
    if (idx != null && idx >= 0 && idx < N){
      inv[idx] = A[i];
    }
  }
  for (let i = 0; i < N; i++){
    if (!inv[i]) inv[i] = A[i];
  }
  return { posFull, inv, invString: inv.join('') };
}

// ===== Vigenère =====
function solveCribVigenere(cipherSeg, plainSeg, keylen, letterStartPos){
  const tpl = Array(keylen).fill(null);
  for (let t=0; t < cipherSeg.length; t++){
    const c = A2I[cipherSeg[t]];
    const p = A2I[plainSeg[t]];
    const kpos = (letterStartPos + t) % keylen;
    const need = ((c - p) % 26 + 26) % 26;
    if (tpl[kpos] === null) tpl[kpos] = need;
    else if (tpl[kpos] !== need) return { ok:false, template:null };
  }
  return { ok:true, template: tpl };
}

function applyVigenereDecrypt(letters, template){
  const keylen = template.length;
  let out = '';
  let step = 0;
  for (let i=0; i < letters.length; i++){
    const ch = letters[i];
    if (!isLetter(ch)){
      out += ch;
      continue;
    }
    const c = A2I[ch.toUpperCase()];
    const kv = template[step % keylen];
    let pCh = '?';
    if (kv !== null){
      const p = ((c - kv) % 26 + 26) % 26;
      pCh = A[p];
    }
    out += pCh;
    step++;
  }
  return out;
}

// ===== MAS+Vig (pre-sub on plaintext) =====
function decodeMASVigLetters(lettersOnlyArr, key, subInv){
  const m = key.length; const out=[];
  for (let i=0;i<lettersOnlyArr.length;i++){
    const c = A2I[lettersOnlyArr[i]];
    const x = (c - key[i % m] + 26) % 26;
    out.push( A[ subInv[x] ] );
  }
  return out;
}

function identityPerm(){ return [...Array(26).keys()]; }
function swapInPlace(arr,i,j){ const t=arr[i]; arr[i]=arr[j]; arr[j]=t; }

function solveMASVigDeterministic(cLetters, constraints, minK, maxK){
  const results=[];
  function fillPerm(p){ const used=new Set(p.filter(v=>v!==null)); const rem=[]; for(let v=0; v<26; v++) if(!used.has(v)) rem.push(v); const out=p.slice(); for(let i=0;i<26;i++){ if(out[i]===null) out[i]=rem.shift(); } return out; }
  function invertPerm(p){ const inv=new Array(26); for(let i=0;i<26;i++){ inv[p[i]] = i; } return inv; }
  for (let m=minK; m<=maxK; m++){
    const s = new Array(26).fill(null);
    const k = new Array(m).fill(null);
    const cons = constraints.map(o=>({ r: o.pos % m, cIdx:o.cIdx, pIdx:o.pIdx }));
    function propagate(){
      let changed=true;
      while (changed){
        changed=false;
        for (const {r,cIdx,pIdx} of cons){
          if (k[r]!==null && s[pIdx]===null){ const val=((cIdx - k[r])%26+26)%26; if (s[pIdx]===null){ s[pIdx]=val; changed=true; } else if (s[pIdx]!==val){ return false; } }
          if (s[pIdx]!==null && k[r]===null){ const val=((cIdx - s[pIdx])%26+26)%26; if (k[r]===null){ k[r]=val; changed=true; } else if (k[r]!==val){ return false; } }
          if (s[pIdx]!==null && k[r]!==null){ if ( ((cIdx - s[pIdx])%26+26)%26 !== k[r]) return false; }
        }
        const seen=new Set();
        for (let i=0;i<26;i++){ const v=s[i]; if (v===null) continue; if (seen.has(v)) return false; seen.add(v); }
      }
      return true;
    }
    function dfs(){
      if (!propagate()) return null;
      if (k.every(v=>v!==null)) return {s:s.slice(), k:k.slice()};
      const counts = new Array(m).fill(0); cons.forEach(({r})=>counts[r]++);
      let rr = -1, best=-1;
      for (let r=0;r<m;r++){ if (k[r]===null && counts[r]>best){best=counts[r]; rr=r;} }
      if (rr<0) return {s:s.slice(), k:k.slice()};
      let cand = null;
      for (const {r,cIdx,pIdx} of cons){ if (r===rr && s[pIdx]!==null){ cand = [ ((cIdx - s[pIdx])%26+26)%26 ]; break; } }
      if (!cand){ cand = [...Array(26).keys()]; }
      for (const val of cand){
        const old = k[rr]; k[rr]=val;
        const res = dfs(); if (res) return res;
        k[rr]=old;
      }
      return null;
    }
    const sol = dfs();
    if (sol){
      const S = fillPerm(sol.s);
      const Sinv = invertPerm(S);
      const dec = [];
      for (let i=0;i<cLetters.length;i++){ const c=A2I[cLetters[i]]; const p = Sinv[ ((c - sol.k[i % m])%26+26)%26 ]; dec.push(A[p]); }
      results.push({m, key:sol.k, subInv:Sinv, plaintext:dec.join('')});
    }
  }
  return results.sort((a,b)=>b.plaintext.length-a.plaintext.length);
}

function solveMASVigSA(fullTextLetters, minK, maxK, iters=4000, tempStart=5.0, tempEnd=0.1, cribConstraints){
  const PENALTY = 200;
  function violationsFor(key, subInv, constraints){
    if (!constraints || !constraints.length) return 0;
    let miss = 0; const m = key.length;
    for (const {pos, cIdx, pIdx} of constraints){
      const kj = key[pos % m];
      const x = ((cIdx - kj) % 26 + 26) % 26;
      if (subInv[x] !== pIdx) miss++;
    }
    return miss;
  }

  const results=[];
  for (let m=minK; m<=maxK; m++){
    let key = Array.from({length:m}, ()=> (Math.random()*26)|0);
    let subInv = identityPerm();

    const evalScore = (k, s) => {
      const dec = decodeMASVigLetters(fullTextLetters, k, s);
      const lang = englishFitness(dec);
      const miss = violationsFor(k, s, cribConstraints);
      return {score: lang - PENALTY*miss, lang, miss, dec};
    };

    let {score:bestScore, lang:bestLang, miss:bestMiss, dec:bestDec} = evalScore(key, subInv);
    let bestKey = key.slice();
    let bestSub = subInv.slice();

    let curKey = key.slice();
    let curSub = subInv.slice();
    let {score:curScore} = evalScore(curKey, curSub);

    const cool = (t)=> tempStart * Math.pow(tempEnd/tempStart, t/iters);

    for (let t=0; t<iters; t++){
      const temp = cool(t);
      if ((t & 1) === 0){
        const j = (Math.random()*m)|0;
        const old = curKey[j];
        const delta = ((Math.random()*7)|0) - 3;
        curKey[j] = (curKey[j] + delta + 26) % 26;
        const {score:s} = evalScore(curKey, curSub);
        const accept = (s>curScore) || (Math.random() < Math.exp((s-curScore)/Math.max(1e-6,temp)));
        if (accept){
          curScore=s;
          if (s>bestScore){
            const ev = evalScore(curKey, curSub);
            bestScore=ev.score; bestLang=ev.lang; bestMiss=ev.miss; bestDec=ev.dec;
            bestKey=curKey.slice(); bestSub=curSub.slice();
          }
        } else {
          curKey[j]=old;
        }
      } else {
        const i = (Math.random()*26)|0, j = (Math.random()*26)|0;
        if (i===j) continue;
        swapInPlace(curSub, i, j);
        const {score:s} = evalScore(curKey, curSub);
        const accept = (s>curScore) || (Math.random() < Math.exp((s-curScore)/Math.max(1e-6,temp)));
        if (accept){
          curScore=s;
          if (s>bestScore){
            const ev = evalScore(curKey, curSub);
            bestScore=ev.score; bestLang=ev.lang; bestMiss=ev.miss; bestDec=ev.dec;
            bestKey=curKey.slice(); bestSub=curSub.slice();
          }
        } else {
          swapInPlace(curSub,i,j);
        }
      }
    }

    const dec = bestDec;
    results.push({m, key:bestKey, subInv:bestSub, score:bestScore, lang:bestLang, violations:bestMiss, plaintext:dec.join('')});
  }
  results.sort((a,b)=>b.score-a.score);
  return results;
}

// ===== MAS+Vig (post-sub on ciphertext) =====
function solveCipherSubDeterministic(cLetters, constraints, minK, maxK){
  const results=[];
  function fillPerm(p){ const used=new Set(p.filter(v=>v!==null)); const rem=[]; for(let v=0; v<26; v++) if(!used.has(v)) rem.push(v); const out=p.slice(); for(let i=0;i<26;i++){ if(out[i]===null) out[i]=rem.shift(); } return out; }
  for (let m=minK; m<=maxK; m++){
    const pMap = new Array(26).fill(null);
    const k = new Array(m).fill(null);
    const cons = constraints.map(o=>({ r:o.pos % m, cIdx:o.cIdx, pIdx:o.pIdx }));
    function propagate(){
      let changed=true;
      while (changed){
        changed=false;
        for (const {r,cIdx,pIdx} of cons){
          if (k[r]!==null && pMap[cIdx]===null){ const val=((pIdx + k[r])%26+26)%26; if (pMap[cIdx]===null){ pMap[cIdx]=val; changed=true; } else if (pMap[cIdx]!==val){ return false; } }
          if (pMap[cIdx]!==null && k[r]===null){ const val=((pMap[cIdx] - pIdx)%26+26)%26; if (k[r]===null){ k[r]=val; changed=true; } else if (k[r]!==val){ return false; } }
          if (pMap[cIdx]!==null && k[r]!==null){ if ( ((pMap[cIdx] - pIdx)%26+26)%26 !== k[r]) return false; }
        }
        const seen=new Set();
        for (let i=0;i<26;i++){ const v=pMap[i]; if (v===null) continue; if (seen.has(v)) return false; seen.add(v); }
      }
      return true;
    }
    function dfs(){
      if (!propagate()) return null;
      if (k.every(v=>v!==null)) return {p:pMap.slice(), k:k.slice()};
      const counts = new Array(m).fill(0); cons.forEach(({r})=>counts[r]++);
      let rr=-1, best=-1; for (let r=0;r<m;r++){ if (k[r]===null && counts[r]>best){best=counts[r]; rr=r;} }
      if (rr<0) return {p:pMap.slice(), k:k.slice()};
      let cand=null; for (const {r,cIdx,pIdx} of cons){ if (r===rr && pMap[cIdx]!==null){ cand = [ ((pMap[cIdx] - pIdx)%26+26)%26 ]; break; } }
      if (!cand) cand=[...Array(26).keys()];
      for (const val of cand){ const old=k[rr]; k[rr]=val; const res=dfs(); if (res) return res; k[rr]=old; }
      return null;
    }
    const sol = dfs();
    if (sol){
      const P = fillPerm(sol.p);
      const dec=[]; for (let i=0;i<cLetters.length;i++){ const c=A2I[cLetters[i]]; dec.push( A[ ((P[c]-sol.k[i % m])%26+26)%26 ] ); }
      results.push({m, key:sol.k, cipherNorm:P, plaintext:dec.join('')});
    }
  }
  return results;
}

// ===== Main test cribs =====
function testCribs(){
  const {letters, cribMap} = gatherCribs();
  const op = document.getElementById('op').value;
  const selectedAutokeyAlgo = op === 'autokey_custom_alpha' ? currentAutokeyAlgo() : null;
  const segments = collectContiguousCribs(letters, cribMap);
  const minK = parseInt(document.getElementById('minK').value);
  const maxK = parseInt(document.getElementById('maxK').value);
  const out = document.getElementById('out');
  out.textContent = '';
  if ((op !== 'vig_sub' && op !== 'vig_sub_post') && segments.length === 0){
    setSummaryMessage('No crib segments entered — enter letters under ciphertext characters.');
    return;
  }

  setSummaryMessage(`Testing ${segments.length} crib segment(s) for key lengths ${minK}..${maxK} using ${op}`);

  if (op === 'vigenere'){
    const {cLetters} = buildLetterStreams(letters);
    const good = [];
    for (let k = minK; k <= maxK; k++){
      let agg = Array(k).fill(null);
      let okAll = true;
      for (const seg of segments){
        const {absToLetterStep} = buildLetterStreams(letters);
        const letterStartPos = absToLetterStep[seg.start];
        const res = solveCribVigenere(seg.cipherSeg, seg.plainSeg, k, letterStartPos);
        if (!res.ok){ okAll = false; break; }
        for (let i=0;i<k;i++){
          const v = res.template[i];
          if (v === null) continue;
          if (agg[i] === null) agg[i] = v; else if (agg[i] !== v){ okAll = false; break; }
        }
        if (!okAll) break;
      }
      if (okAll) good.push({ k, template: agg });
    }
    if (good.length === 0){ out.textContent = 'No consistent key lengths found.'; return; }

    let text = '';
    for (const g of good){
      const tpl = g.template.map(x => x===null ? '?' : A[x]).join('');
      text += 'Key length: ' + g.k + ' (Vigenère)\n';
      text += 'Key template: ' + tpl + '\n';
      text += 'Partial decrypt:\n';
      text += applyVigenereDecrypt(letters, g.template) + '\n\n';
    }
    out.textContent = text;
    return;
  }

  if (op === 'vig_sub'){
    const { cLetters } = buildLetterStreams(letters);
    const constraints = [];
    if (segments.length){
      for (const seg of segments){
        let letterIdx=-1; for (let i=0,seen=0;i<letters.length;i++){ if (isLetter(letters[i])){ if (i===seg.start){ letterIdx=seen; break;} seen++; } }
        if (letterIdx>=0){
          for (let t=0; t<seg.cipherSeg.length; t++){
            const pos = letterIdx + t;
            const cIdx = A2I[seg.cipherSeg[t]];
            const pIdx = A2I[seg.plainSeg[t]];
            constraints.push({pos, cIdx, pIdx});
          }
        }
      }
    }
    let text='';
    if (constraints.length){
      const det = solveMASVigDeterministic(cLetters, constraints, minK, maxK);
      if (det.length){
        for (const r of det.slice(0,3)){
          const keyStr = r.key.map(v=>A[v]).join('');
          const S = new Array(26); for (let i=0;i<26;i++) S[ r.subInv[i] ] = i;
          const sMap = S.map(x=>A[x]).join('');
          text += `[exact from cribs] m=${r.m}  key=${keyStr}\n`;
          text += `S mapping: ${sMap}\n`;
          text += `crib-consistency: 100% (all crib letters satisfied)\n`;
          let outFull=''; let kpos=0; for (let i=0;i<letters.length;i++){ const ch=letters[i]; if (!isLetter(ch)){ outFull+=ch; } else { outFull+= r.plaintext[kpos++]; } }
          text += 'Decrypt attempt:\n' + outFull + '\n\n';
        }
        out.textContent = text; return;
      }
    }
    const res = solveMASVigSA(cLetters, minK, maxK, 6000, 6.0, 0.1, constraints);
    for (const r of res.slice(0,3)){
      const keyStr = r.key.map(v=>A[v]).join('');
      const S = new Array(26); for (let i=0;i<26;i++) S[ r.subInv[i] ] = i;
      const sMap = S.map(x=>A[x]).join('');
      text += `m=${r.m}  langScore/100=${(r.lang||r.score).toFixed(2)}
key (residues): ${keyStr}
S mapping: ${sMap}
`;
      if (constraints.length){ text += `crib-consistency: ${constraints.length - (r.violations||0)}/${constraints.length}
`; }
      let outFull=''; let kpos=0; for (let i=0;i<letters.length;i++){ const ch=letters[i]; if (!isLetter(ch)){ outFull+=ch; } else { outFull+= r.plaintext[kpos++]; } }
      text += 'Decrypt attempt:\n' + outFull + '\n\n';
    }
    out.textContent = text || 'No result';
    return;
  }

  if (op === 'vig_sub_post'){
    const { cLetters } = buildLetterStreams(letters);
    const constraints = [];
    if (segments.length){
      for (const seg of segments){
        let letterIdx=-1; for (let i=0,seen=0;i<letters.length;i++){ if (isLetter(letters[i])){ if (i===seg.start){ letterIdx=seen; break;} seen++; } }
        if (letterIdx>=0){
          for (let t=0; t<seg.cipherSeg.length; t++){
            const pos = letterIdx + t;
            const cIdx = A2I[seg.cipherSeg[t]];
            const pIdx = A2I[seg.plainSeg[t]];
            constraints.push({pos, cIdx, pIdx});
          }
        }
      }
    }
    const det = solveCipherSubDeterministic(cLetters, constraints, minK, maxK);
    let text='';
    for (const r of det.slice(0,3)){
      const keyStr = r.key.map(v=>A[v]).join('');
      text += `[exact from cribs] m=${r.m}  key=${keyStr}\n`;
      let outFull=''; let kpos=0; for (let i=0;i<letters.length;i++){ const ch=letters[i]; if (!isLetter(ch)){ outFull+=ch; } else { outFull+= r.plaintext[kpos++]; } }
      text += 'Decrypt attempt:\n' + outFull + '\n\n';
    }
    out.textContent = text || 'No result';
    return;
  }
}

// ===== Wordlist brute force =====
document.getElementById('wordlistFile').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    const text = ev.target.result;
    wordlist = text.split(/\r?\n/).map(w => sanitize(w.trim())).filter(w => w.length > 0);
    document.getElementById('wordlistStatus').textContent = `Loaded ${wordlist.length} words`;
  };
  reader.readAsText(file);
});

function bruteForceWordlist(){
  if (wordlist.length === 0){
    alert('Please upload a wordlist first');
    return;
  }

  if (selectionStart === -1 || selectionEnd === -1){
    alert('Please select a word position first using "Select Word Position" button');
    return;
  }

  const {letters, cribMap} = gatherCribs();
  const startPos = Math.min(selectionStart, selectionEnd);
  const endPos = Math.max(selectionStart, selectionEnd);
  const selectionLength = endPos - startPos + 1;

  const bridgeNextEl = document.getElementById('bruteBridgeNext');
  const bridgeNext = bridgeNextEl ? !!bridgeNextEl.checked : false;
  const nextSegmentLen = bridgeNext ? findNextCribSegmentAfter(letters, cribMap, endPos).length : 0;

  let maxResults = parseInt(document.getElementById('maxResults').value, 10);
  if (!Number.isFinite(maxResults) || maxResults <= 0){ maxResults = 20; }
  const minK = parseInt(document.getElementById('minK').value, 10);
  const maxK = parseInt(document.getElementById('maxK').value, 10);
  const op = document.getElementById('op').value;
  const quickTrials = getQuickTrials();
  const trialDepth = getTrialDepth();

  const filtered = wordlist.filter(w => w.length === selectionLength);
  const wrongLengthSkipped = wordlist.length - filtered.length;

  if (filtered.length === 0){
    displayBruteResults([], startPos, endPos, 0, wrongLengthSkipped, 0, maxResults, { bridgeNext, nextSegmentLen, timedOutWords: 0, autokeyAlgo: selectedAutokeyAlgo });
    return;
  }

  const cribPairs = [];
  Object.entries(cribMap).forEach(([pos, val]) => {
    const clean = sanitize(typeof val === 'string' ? val : '');
    if (clean && clean.length > 0){
      cribPairs.push([parseInt(pos, 10), clean[0]]);
    }
  });

  const payload = {
    letters,
    cribPairs,
    wordlist: filtered,
    startPos,
    endPos,
    selectionLength,
    minK,
    maxK,
    op,
    autokeyAlgo: currentAutokeyAlgo(),
    maxResults,
    quickTrials,
    trialDepth,
    wordTimeoutMs: getWordTimeoutMs(),
    preSkipped: wrongLengthSkipped,
    bridgeNext: !!bridgeNext
  };

  if (typeof window !== 'undefined' && typeof window.__startBruteWorker === 'function'){
    window.__startBruteWorker(payload);
  } else {
    console.warn('Brute-force worker controller unavailable.');
  }
}

function displayBruteResults(results, startPos, endPos, wordsChecked, wordsSkipped, totalCandidates, maxResults, options){
  const opts = options || {};
  const bridgeNext = !!opts.bridgeNext;
  const nextSegmentLen = (typeof opts.nextSegmentLen === 'number') ? opts.nextSegmentLen : undefined;
  const timedOutWords = (typeof opts.timedOutWords === 'number') ? opts.timedOutWords : 0;
  const variantLabel = opts.autokeyAlgo ? autokeyAlgoLabel(opts.autokeyAlgo) : null;
  const panel = document.getElementById('bruteResults');
  const summary = document.getElementById('bruteSummary');
  const out = document.getElementById('bruteOut');

  panel.style.display = 'block';
  const shown = results.length;
  const total = (typeof totalCandidates === 'number') ? totalCandidates : shown;
  const limit = (typeof maxResults === 'number' && !Number.isNaN(maxResults)) ? maxResults : shown;
  const timeoutText = timedOutWords > 0 ? `, timed out ${timedOutWords}` : '';
  let text = `Found ${total} consistent cribs at positions ${startPos}-${endPos}. Showing top ${shown} (limit ${limit}). Checked ${wordsChecked} words (skipped ${wordsSkipped} wrong-length words${timeoutText}). Sorted by decryption quality.`;
  if (variantLabel){
    text += ` Autokey variant: ${variantLabel}.`;
  }
  if (bridgeNext){
    if (nextSegmentLen === undefined){
      text += ' Enforcing next crib segment (length pending).';
    } else if (nextSegmentLen > 0){
      text += ` Enforced next crib segment (${nextSegmentLen} letter${nextSegmentLen === 1 ? '' : 's'}).`;
    } else {
      text += ' Enforce-next-crib enabled, but no later crib segment was found to apply.';
    }
  }
  summary.textContent = text;

  out.innerHTML = '';
  results.forEach((r, idx) => {
    const div = document.createElement('div');
    div.className = idx < 5 ? 'result-item top' : 'result-item';

    const wordSpan = document.createElement('div');
    const variantInfo = r.autokeyAlgo ? ` | <strong>Variant:</strong> ${autokeyAlgoLabel(r.autokeyAlgo)}` : '';
    const keyDisplay = r.actualKey || r.key;
    const residuesInfo = (r.actualKey && r.actualKey !== r.key) ? ` <span class="muted small">(residues ${r.key})</span>` : '';
    wordSpan.innerHTML = `<strong>Word:</strong> ${r.word} | <strong>Key Length:</strong> ${r.keyLength} | <strong>Key:</strong> ${keyDisplay}${variantInfo} | <span class="score">Score: ${r.fitness.toFixed(2)}</span>${residuesInfo}`;
    
    const decSpan = document.createElement('pre');
    decSpan.textContent = r.decrypted;
    decSpan.style.fontSize = '12px';
    decSpan.style.marginTop = '4px';
    
    div.appendChild(wordSpan);
    
    // Show alphabet line when present (unknown alphabet full expansions)
    if (r.alphabet) {
      const alphaSpan = document.createElement('div');
      alphaSpan.innerHTML = `<strong>Alphabet:</strong> ${r.alphabet}`;
      div.appendChild(alphaSpan);
    }

    div.appendChild(decSpan);
    out.appendChild(div);
  });
}

// ===== Events =====
renderGrid();
document.getElementById('render').addEventListener('click', renderGrid);
document.getElementById('test').addEventListener('click', testCribs);
document.getElementById('selectMode').addEventListener('click', toggleSelectionMode);
document.getElementById('bruteForce').addEventListener('click', bruteForceWordlist);

// ===== Progress (lazy) =====
function ensureProgressPanel(){
  let panel = document.getElementById('progressPanel');
  if (panel) return panel;
  const after = document.getElementById('out');
  panel = document.createElement('div');
  panel.id = 'progressPanel';
  panel.className = 'panel thinking-panel';
  const lab = document.createElement('div');
  lab.id = 'progressLabel';
  lab.className = 'thinking-text';
  lab.textContent = 'Thinking...';
  panel.appendChild(lab);
  if (after && after.parentNode){
    after.parentNode.insertBefore(panel, after.nextSibling);
  } else {
    document.body.appendChild(panel);
  }
  return panel;
}
function showProgress(total){
  const panel = ensureProgressPanel();
  panel.style.display = 'flex';
  panel.dataset.total = String(Math.max(1, total || 1));
  panel.dataset.done = '0';
  lastHeatScore = 0;
  restartThinkingAnimation('Thinking');
}
function updateProgress(done){
  const panel = document.getElementById('progressPanel');
  if (!panel) return;
  panel.dataset.done = String(Math.max(0, done|0));
}
function hideProgress(){
  const panel = document.getElementById('progressPanel');
  if (panel){
    panel.style.display = 'none';
  }
  stopThinkingAnimation();
}
function uiYield(){ return new Promise(r=>setTimeout(r,0)); }

// ===== Unknown alphabet Vigenère solver =====


function solveVigUnknownAlphabet(letters, cribMap, m, options){
  const N=26;
  // Build constraints from contiguous crib segments using letter indices (robust to punctuation)
  const segments = collectContiguousCribs(letters, cribMap);
  const { cLetters, absToLetterStep } = buildLetterStreams(letters);
  const cons=[];
  for (const seg of segments){
    // Map absolute start to letter index
    let letterIdx=-1;
    for (let i=0, seen=0; i<letters.length; i++){
      if (isLetter(letters[i])){
        if (i === seg.start){ letterIdx=seen; break; }
        seen++;
      }
    }
    if (letterIdx < 0) continue;
    for (let t=0; t<seg.cipherSeg.length; t++){
      const pos = letterIdx + t;
      const r = pos % m;
      const pSym = A2I[seg.plainSeg[t]];
      const cSym = A2I[seg.cipherSeg[t]];
      cons.push({ r, pSym, cSym });
    }
  }
  if (!cons.length) return null;

  const pos = new Array(N).fill(null), used=new Array(N).fill(false);
  const k = new Array(m).fill(null);
  function mod(a){ a%=N; if(a<0)a+=N; return a; }
  const byR = Array.from({length:m},()=>[]); cons.forEach(c=>byR[c.r].push(c));

  // Gauge fix: anchor the most-connected letter to position 0 to break rotational symmetry
  const countsDeg = new Array(N).fill(0); cons.forEach(({pSym,cSym})=>{countsDeg[pSym]++; countsDeg[cSym]++;});
  let anchor=-1, bestDeg=-1; for (let L=0; L<N; L++){ if (countsDeg[L]>bestDeg){ bestDeg=countsDeg[L]; anchor=L; } }
  if (anchor!==-1){ pos[anchor]=0; used[0]=true; }

  function propagate(){
    let changed=true;
    while(changed){
      changed=false;
      // If both plaintext/cipher positions are known for a constraint, it sets k[r]
      for (const {r,pSym,cSym} of cons){
        const vp=pos[pSym], vc=pos[cSym];
        if (vp!==null && vc!==null){
          const need=mod(vc-vp);
          if (k[r]===null){ k[r]=need; changed=true; }
          else if (k[r]!==need) return false;
        }
      }
      // If k[r] is known, propagate positions
      for (const {r,pSym,cSym} of cons){
        const vr=k[r]; if (vr===null) continue;
        const vp=pos[pSym], vc=pos[cSym];
        if (vp!==null && vc===null){
          const need=mod(vp+vr);
          if (used[need] && pos[cSym]!==need) return false;
          if (pos[cSym]===null){ pos[cSym]=need; used[need]=true; changed=true; }
          else if (pos[cSym]!==need) return false;
        } else if (vp===null && vc!==null){
          const need=mod(vc-vr);
          if (used[need] && pos[pSym]!==need) return false;
          if (pos[pSym]===null){ pos[pSym]=need; used[need]=true; changed=true; }
          else if (pos[pSym]!==need) return false;
        }
      }
      // Enforce bijection
      const seen=new Set();
      for (let L=0;L<N;L++){
        const v=pos[L]; if (v===null) continue;
        if (seen.has(v)) return false; seen.add(v); used[v]=true;
      }
    }
    return true;
  }

  // Quick-propagation-only mode: do a bit more than a single propagation to reduce false positives.
  if (options && options.propagateOnly){
    // First, do deterministic propagation. If that fails, candidate is impossible.
    const ok = propagate();
    if (!ok) return false;

    // If everything is already assigned, success.
    const allAssigned = pos.every(x => x!==null) && k.every(x => x!==null);
    if (allAssigned) return true;

    // Perform a small number of shallow randomized trials: pick an unassigned variable, assign
    // a plausible small candidate set (derived from diffs if available, otherwise random), propagate,
    // and accept if any trial leads to a consistent partial assignment. This is still cheap
    // compared to a full DFS.
    const MAX_TRIALS = (options && options.quickTrials) ? options.quickTrials : 30;

    // Prepare candidate diffs per residue where useful
    const residueCandidates = {};
    for (let r=0;r<m;r++){
      const group = byR[r];
      const diffs = new Set();
      for (let i=0;i<group.length;i++){
        for (let j=i+1;j<group.length;j++){
          const a = group[i], b = group[j];
          if (a.pSym === b.pSym){
            if (pos[a.pSym]!==null && pos[a.cSym]!==null) diffs.add(mod(pos[a.cSym]-pos[a.pSym]));
            if (pos[b.pSym]!==null && pos[b.cSym]!==null) diffs.add(mod(pos[b.cSym]-pos[b.pSym]));
          }
          if (a.cSym === b.cSym){
            if (pos[a.cSym]!==null && pos[a.pSym]!==null) diffs.add(mod(pos[a.cSym]-pos[a.pSym]));
            if (pos[b.cSym]!==null && pos[b.pSym]!==null) diffs.add(mod(pos[b.cSym]-pos[b.pSym]));
          }
        }
      }
      if (diffs.size) residueCandidates[r] = Array.from(diffs);
    }

    function snap(){ return { pos: pos.slice(), used: used.slice(), k: k.slice() }; }
    function restore(S){ for (let i=0;i<26;i++){ pos[i]=S.pos[i]; used[i]=S.used[i]; } for (let i=0;i<k.length;i++){ k[i]=S.k[i]; } }

    // Identify a small set of unassigned variables to try: residues first, then letters.
    const unassignedResidues = [];
    for (let r=0;r<m;r++) if (k[r]===null) unassignedResidues.push(r);
    const appear = new Set(); cons.forEach(({pSym,cSym})=>{ appear.add(pSym); appear.add(cSym); });
    const letterCounts = new Array(N).fill(0); cons.forEach(({pSym,cSym})=>{ letterCounts[pSym]++; letterCounts[cSym]++; });
    const unassignedLetters = [];
    for (let L=0; L<N; L++) if (appear.has(L) && pos[L]===null) unassignedLetters.push(L);

    // Trial loop
    
    for (let t=0; t<MAX_TRIALS; t++){
      const S = snap();
      let assignedAny = false;
      // perform up to TRIAL_DEPTH greedy assignment layers within this single trial
      const TRIAL_DEPTH = (options && options.trialDepth) ? Math.max(0, options.trialDepth) : 3;
      let failed = false;
      for (let layer=0; layer<TRIAL_DEPTH; layer++){
        // pick variable: prefer residues, then letters
        let picked = null;
        if (unassignedResidues.length){
          // try to find residue with candidates first
          for (const r of unassignedResidues){ if (residueCandidates[r] && residueCandidates[r].length){ picked = {type:'r', idx:r}; break; } }
          if (!picked) picked = {type:'r', idx: unassignedResidues[Math.floor(Math.random()*unassignedResidues.length)]};
        } else if (unassignedLetters.length){
          picked = {type:'p', idx: unassignedLetters[Math.floor(Math.random()*unassignedLetters.length)]};
        } else {
          break;
        }
        if (picked.type === 'r'){
          const r = picked.idx;
          const cand = (residueCandidates[r] && residueCandidates[r].length) ? residueCandidates[r] : [...Array(26).keys()];
          // limit branching per layer to a small number to keep trial cheap
          const BRANCH = 3;
          // try up to BRANCH random candidates from cand
          let triedAny=false;
          for (let bi=0; bi<BRANCH; bi++){
            const val = cand[Math.floor(Math.random()*cand.length)];
            k[r] = val; assignedAny = true;
            // propagate quickly
            if (propagate()){
              triedAny=true;
              break; // proceed to next layer
            } else {
              // revert this residue assignment and try next candidate
              k[r] = S.k[r];
              // continue trying other candidates
            }
          }
          if (!triedAny){ failed = true; break; }
        } else {
          // assign a letter
          const L = picked.idx;
          const free = [];
          for (let v=0; v<26; v++) if (!used[v]) free.push(v);
          if (!free.length){ failed = true; break; }
          // limit branching per layer
          const BRANCH = 3;
          let triedAny=false;
          for (let bi=0; bi<BRANCH; bi++){
            const v = free[Math.floor(Math.random()*free.length)];
            pos[L] = v; used[v]=true; assignedAny=true;
            if (propagate()){ triedAny=true; break; }
            else { pos[L]=S.pos[L]; for (let ii=0; ii<26; ii++) used[ii]=S.used[ii]; }
          }
          if (!triedAny){ failed = true; break; }
        }
        // update unassigned lists
        // recompute simple arrays (cheap)
        unassignedResidues.length = 0;
        for (let r=0;r<m;r++) if (k[r]===null) unassignedResidues.push(r);
        unassignedLetters.length = 0;
        const appearLocal = new Set(); cons.forEach(({pSym,cSym})=>{ appearLocal.add(pSym); appearLocal.add(cSym); });
        for (let L=0; L<26; L++) if (appearLocal.has(L) && pos[L]===null) unassignedLetters.push(L);
      } // end layers

      // After layers, if propagation left a consistent state, accept as viable
      if (!failed){
        const ok2 = propagate();
        if (ok2) return true;
      }

      // restore and continue next trial
      restore(S);
    }

    return false;
  }

  function chooseVar(){
    // Prefer a residue with most constraints among residues that actually appear
    let bestR=-1,best=-1;
    for (let r=0;r<m;r++){ if (k[r]!==null) continue; const cnt=byR[r].length; if (cnt>best){best=cnt;bestR=r;} }
    if (bestR!==-1) return {type:'r', idx:bestR};
    // Then pick the most connected LETTER among only those that appear in constraints
    const appear = new Set(); cons.forEach(({pSym,cSym})=>{ appear.add(pSym); appear.add(cSym); });
    const counts=new Array(N).fill(0); cons.forEach(({pSym,cSym})=>{counts[pSym]++; counts[cSym]++;});
    let bestL=-1,b=-1; for (let L=0;L<N;L++){ if (!appear.has(L)) continue; if (pos[L]===null && counts[L]>b){ b=counts[L]; bestL=L; } }
    if (bestL!==-1) return {type:'p', idx:bestL};
    return null;
  }

  function dfs(){
    function snap(){
      return { pos: pos.slice(), used: used.slice(), k: k.slice() };
    }
    function restore(S){
      for (let i=0;i<26;i++){ pos[i]=S.pos[i]; used[i]=S.used[i]; }
      for (let i=0;i<k.length;i++){ k[i]=S.k[i]; }
    }

    if (!propagate()) return null;
    const varSel = chooseVar();
    if (!varSel){
      const posFull = pos.slice();
      const freePos = []; for (let v=0; v<26; v++){ if (!used[v]) freePos.push(v); }
      for (let L=0; L<26; L++){ if (posFull[L]===null) posFull[L] = freePos.shift(); }
      const key = k.slice().map(x => x===null ? 0 : x);
      return { pos: posFull, k: key };
    }

    const mod = (x)=>((x%26)+26)%26;

    if (varSel.type === 'r'){
      const r = varSel.idx;
      let cand = null;
      for (const { r: rr, pSym, cSym } of byR[r]){
        if (rr!==r) continue;
        if (pos[pSym]!==null && pos[cSym]!==null){
          cand = [ mod(pos[cSym]-pos[pSym]) ];
          break;
        }
      }
      if (!cand){
        const diffs = new Set();
        const group = byR[r];
        for (let i=0;i<group.length;i++){
          for (let j=i+1;j<group.length;j++){
            const a=group[i], b=group[j];
            if (a.pSym===b.pSym){
              const p=a.pSym;
              if (pos[p]!==null && pos[a.cSym]!==null) diffs.add(mod(pos[a.cSym]-pos[p]));
              if (pos[p]!==null && pos[b.cSym]!==null) diffs.add(mod(pos[b.cSym]-pos[p]));
            }
            if (a.cSym===b.cSym){
              const c=a.cSym;
              if (pos[c]!==null && pos[a.pSym]!==null) diffs.add(mod(pos[c]-pos[a.pSym]));
              if (pos[c]!==null && pos[b.pSym]!==null) diffs.add(mod(pos[c]-pos[b.pSym]));
            }
          }
        }
        const arr = [...diffs];
        cand = arr.length ? arr : [...Array(26).keys()];
      }
      for (const val of cand){
        const S = snap();
        k[r] = val;
        const res = dfs();
        if (res) return res;
        restore(S);
      }
      return null;
    } else {
      const L = varSel.idx;
      const free = []; for (let v=0; v<26; v++){ if (!used[v]) free.push(v); }
      for (const v of free){
        const S = snap(); pos[L] = v; used[v]=true;
        const res = dfs(); if (res) return res;
        restore(S);
      }
      return null;
    }
  }

  const sol = dfs();
  if (!sol) return null;
  return { pos: sol.pos, k: sol.k };
}



function solveAutokeyUnknownAlphabet(letters, cribMap, m, options, algo){
  const opts = (options && typeof options === 'object') ? options : null;
  if (opts){
    opts.timedOut = false;
    opts.visitedNodes = 0;
  }
  const N = 26;
  let timedOut = false;
  let nodeVisits = 0;
  const maxMillis = (opts && Number.isFinite(opts.maxMillis) && opts.maxMillis > 0) ? opts.maxMillis : null;
  const maxNodes = (opts && Number.isFinite(opts.maxNodes) && opts.maxNodes > 0) ? opts.maxNodes|0 : null;
  const timeFn = (typeof performance !== 'undefined' && typeof performance.now === 'function')
    ? () => performance.now()
    : () => Date.now();
  const hasTimeLimit = maxMillis !== null;
  const startTime = hasTimeLimit ? timeFn() : 0;
  function limitReached(){
    if (timedOut) return true;
    if (hasTimeLimit && (timeFn() - startTime) >= maxMillis){
      timedOut = true;
      return true;
    }
    if (maxNodes !== null && nodeVisits >= maxNodes){
      timedOut = true;
      return true;
    }
    return false;
  }
  if (!Number.isFinite(m) || m <= 0) return null;
  const segments = collectContiguousCribs(letters, cribMap);
  if (!segments.length) return null;
  const { absToLetterStep } = buildLetterStreams(letters);
  const stepPlain = new Map();
  const stepCipher = new Map();
  for (const seg of segments){
    const startStep = absToLetterStep[seg.start];
    if (startStep == null || startStep < 0) continue;
    for (let t=0; t<seg.cipherSeg.length; t++){
      const step = startStep + t;
      const pSym = A2I[seg.plainSeg[t]];
      const cSym = A2I[seg.cipherSeg[t]];
      if (stepPlain.has(step) && stepPlain.get(step) !== pSym) return null;
      if (stepCipher.has(step) && stepCipher.get(step) !== cSym) return null;
      stepPlain.set(step, pSym);
      stepCipher.set(step, cSym);
    }
  }
  if (!stepPlain.size) return null;

  const constraints = [];
  const letterDeg = new Array(N).fill(0);
  const keyDeg = new Array(m).fill(0);
  const steps = Array.from(stepPlain.keys()).sort((a,b)=>a-b);
  for (const step of steps){
    const pSym = stepPlain.get(step);
    const cSym = stepCipher.get(step);
    if (pSym == null || cSym == null) continue;
    if (step < m){
      constraints.push({ type:'init', idx:step, pSym, cSym });
      keyDeg[step]++;
    }
    const depStep = step - m;
    if (depStep >= 0 && stepPlain.has(depStep)){
      const depSym = stepPlain.get(depStep);
      constraints.push({ type:'feed', idx:step, pSym, cSym, depSym });
      letterDeg[depSym]++;
    }
    letterDeg[pSym]++;
    letterDeg[cSym]++;
  }
  if (!constraints.length) return null;

  const pos = new Array(N).fill(null);
  const used = new Array(N).fill(false);
  const keyInit = new Array(m).fill(null);

  const mod = (x)=>((x%N)+N)%N;
  const algorithm = normalizeAutokeyAlgo(algo);
  const ops = autokeyOpsFor(algorithm);
  const keyFromPlainCipher = (p, c) => mod(ops.keyFromPlainCipher(p, c));
  const cipherFromPlainKey = (p, k) => mod(ops.cipherFromPlainKey(p, k));
  const plainFromCipherKey = (c, k) => mod(ops.plainFromCipherKey(c, k));

  function assignLetter(idx, value){
    if (idx == null) return {ok:true, changed:false};
    value = mod(value);
    if (pos[idx] === null){
      if (used[value]) return {ok:false, changed:false};
      pos[idx] = value;
      used[value] = true;
      return {ok:true, changed:true};
    }
    return {ok: pos[idx] === value, changed:false};
  }

  function assignKey(idx, value){
    value = mod(value);
    if (keyInit[idx] === null){
      keyInit[idx] = value;
      return {ok:true, changed:true};
    }
    return {ok: keyInit[idx] === value, changed:false};
  }

  function propagate(){
    let changed = true;
    while (changed){
      if (limitReached()) return false;
      changed = false;
      for (const cons of constraints){
        if (limitReached()) return false;
        if (cons.type === 'init'){
          const a = pos[cons.pSym];
          const b = pos[cons.cSym];
          const keyVal = keyInit[cons.idx];
          if (a !== null && b !== null){
            const res = assignKey(cons.idx, keyFromPlainCipher(a, b));
            if (!res.ok) return false;
            if (res.changed) changed = true;
          }
          if (a !== null && keyVal !== null){
            const res = assignLetter(cons.cSym, cipherFromPlainKey(a, keyVal));
            if (!res.ok) return false;
            if (res.changed) changed = true;
          }
          if (b !== null && keyVal !== null){
            const res = assignLetter(cons.pSym, plainFromCipherKey(b, keyVal));
            if (!res.ok) return false;
            if (res.changed) changed = true;
          }
        } else {
          const a = pos[cons.pSym];
          const b = pos[cons.cSym];
          const dep = pos[cons.depSym];
          if (a !== null && dep !== null){
            const res = assignLetter(cons.cSym, cipherFromPlainKey(a, dep));
            if (!res.ok) return false;
            if (res.changed) changed = true;
          }
          const bNow = pos[cons.cSym];
          const aNow = pos[cons.pSym];
          const depNow = pos[cons.depSym];
          if (bNow !== null && aNow !== null){
            const res = assignLetter(cons.depSym, keyFromPlainCipher(aNow, bNow));
            if (!res.ok) return false;
            if (res.changed) changed = true;
          }
          if (bNow !== null && depNow !== null){
            const res = assignLetter(cons.pSym, plainFromCipherKey(bNow, depNow));
            if (!res.ok) return false;
            if (res.changed) changed = true;
          }
        }
      }
    }
    if (limitReached()) return false;
    return true;
  }

  function chooseVar(){
    let bestLetter=-1, bestScore=-1;
    for (let L=0; L<N; L++){
      if (pos[L]===null && letterDeg[L]>bestScore){
        bestScore = letterDeg[L];
        bestLetter = L;
      }
    }
    if (bestLetter !== -1 && bestScore>0) return {type:'letter', idx:bestLetter};
    let bestKey=-1, bestKeyScore=-1;
    for (let i=0;i<m;i++){
      if (keyInit[i]===null && keyDeg[i]>bestKeyScore){
        bestKeyScore = keyDeg[i];
        bestKey = i;
      }
    }
    if (bestKey !== -1 && bestKeyScore>0) return {type:'key', idx:bestKey};
    return null;
  }

  function snapshot(){
    return { pos: pos.slice(), used: used.slice(), key: keyInit.slice() };
  }
  function restore(state){
    for (let i=0;i<N;i++){ pos[i]=state.pos[i]; used[i]=state.used[i]; }
    for (let i=0;i<m;i++){ keyInit[i]=state.key[i]; }
  }

  function dfs(){
    if (limitReached()) return null;
    nodeVisits++;
    if (limitReached()) return null;
    if (!propagate()) return null;
    if (limitReached()) return null;
    const sel = chooseVar();
    if (!sel){
      const posFull = pos.slice();
      const free = [];
      for (let v=0; v<N; v++){ if (!used[v]) free.push(v); }
      for (let L=0; L<N; L++){ if (posFull[L]===null) posFull[L] = free.shift(); }
      const keyFull = keyInit.slice().map(x => x===null ? 0 : mod(x));
      return { pos: posFull, k: keyFull };
    }
    if (sel.type === 'letter'){
      const candSet = new Set();
      for (const cons of constraints){
        if (cons.pSym === sel.idx){
          if (cons.type === 'init'){
            const b = pos[cons.cSym];
            const keyVal = keyInit[cons.idx];
            if (b !== null && keyVal !== null) candSet.add(plainFromCipherKey(b, keyVal));
          } else {
            const b = pos[cons.cSym];
            const dep = pos[cons.depSym];
            if (b !== null && dep !== null) candSet.add(plainFromCipherKey(b, dep));
          }
        }
        if (cons.cSym === sel.idx){
          if (cons.type === 'init'){
            const a = pos[cons.pSym];
            const keyVal = keyInit[cons.idx];
            if (a !== null && keyVal !== null) candSet.add(cipherFromPlainKey(a, keyVal));
          } else {
            const a = pos[cons.pSym];
            const dep = pos[cons.depSym];
            if (a !== null && dep !== null) candSet.add(cipherFromPlainKey(a, dep));
          }
        }
        if (cons.type === 'feed' && cons.depSym === sel.idx){
          const a = pos[cons.pSym];
          const b = pos[cons.cSym];
          if (b !== null && a !== null) candSet.add(keyFromPlainCipher(a, b));
        }
      }
      const free = [];
      for (let v=0; v<N; v++){ if (!used[v]) free.push(v); }
      const candidates = candSet.size ? Array.from(candSet).filter(v => !used[v]) : free;
      for (const val of candidates){
        const snap = snapshot();
        const vv = mod(val);
        pos[sel.idx] = vv;
        used[vv] = true;
        const res = dfs();
        if (res) return res;
        if (timedOut) return null;
        restore(snap);
      }
    } else {
      const candSet = new Set();
      for (const cons of constraints){
        if (cons.type === 'init' && cons.idx === sel.idx){
          const a = pos[cons.pSym];
          const b = pos[cons.cSym];
          if (a !== null && b !== null) candSet.add(keyFromPlainCipher(a, b));
        }
      }
      const candidates = candSet.size ? Array.from(candSet) : [...Array(N).keys()];
      for (const val of candidates){
        const snap = snapshot();
        keyInit[sel.idx] = mod(val);
        const res = dfs();
        if (res) return res;
        if (timedOut) return null;
        restore(snap);
      }
    }
    return null;
  }

  if (options && options.propagateOnly){
    return propagate();
  }

  const solved = dfs();
  if (opts){
    opts.timedOut = timedOut;
    opts.visitedNodes = nodeVisits;
  }
  return solved;
}


function decryptWithCustomAlphabet(letters, pos, k){
  const N=26;
  const inv=new Array(N); for (let L=0;L<N;L++) inv[pos[L]] = A[L];
  let out=''; let step=0;
  for (let i=0;i<letters.length;i++){
    const ch=letters[i];
    if (!isLetter(ch)){ out+=ch; continue; }
    const cIdx = pos[A2I[ch.toUpperCase()]];
    const pIdx = ((cIdx - k[step % k.length]) % N + N) % N;
    out += inv[pIdx];
    step++;
  }
  return out;
}

function decryptAutokeyUnknownAlphabet(letters, pos, keyInit, algo){
  const N = 26;
  const inv = new Array(N); for (let L=0; L<N; L++) inv[pos[L]] = A[L];
  const plainPositions = [];
  let step = 0;
  let out = '';
  const mod = (x)=>((x%N)+N)%N;
  const algorithm = normalizeAutokeyAlgo(algo);
  const ops = autokeyOpsFor(algorithm);
  const plainFromCipherKey = (c, k) => mod(ops.plainFromCipherKey(c, k));
  for (let i=0; i<letters.length; i++){
    const ch = letters[i];
    if (!isLetter(ch)){ out += ch; continue; }
    const cIdx = pos[A2I[ch.toUpperCase()]];
    let keyVal;
    if (step < keyInit.length){
      keyVal = keyInit[step];
    } else {
      keyVal = plainPositions[step - keyInit.length];
    }
    if (keyVal == null) keyVal = 0;
    keyVal = mod(keyVal);
    const pIdx = plainFromCipherKey(cIdx, keyVal);
    plainPositions.push(pIdx);
    out += inv[pIdx];
    step++;
  }
  return out;
}

function autokeyCoverageDiagnostics(letters, cribMap, m){
  const segments = collectContiguousCribs(letters, cribMap);
  const { absToLetterStep } = buildLetterStreams(letters);
  const stepPlain = new Map();
  const stepCipher = new Map();
  for (const seg of segments){
    const startStep = absToLetterStep[seg.start];
    if (startStep == null || startStep < 0) continue;
    for (let t=0; t<seg.cipherSeg.length; t++){
      const step = startStep + t;
      const pSym = A2I[seg.plainSeg[t]];
      const cSym = A2I[seg.cipherSeg[t]];
      if (!stepPlain.has(step)) stepPlain.set(step, pSym);
      if (!stepCipher.has(step)) stepCipher.set(step, cSym);
    }
  }
  const residues = Array.from({length:m}, ()=>0);
  const missing = [];
  let feedLinks = 0;
  const steps = Array.from(stepPlain.keys()).sort((a,b)=>a-b);
  for (const step of steps){
    residues[step % m]++;
    const dep = step - m;
    if (dep >= 0){
      feedLinks++;
      if (!stepPlain.has(dep)){
        missing.push({ step, dependsOn: dep });
      }
    }
  }
  return {
    totalSteps: stepPlain.size,
    residues,
    feedLinks,
    missingFeed: missing
  };
}

// ===== Non-destructive wrapper for Test button =====
async function runUnknownAlphabetInline(){
  const op = document.getElementById('op').value;
  if (op !== 'vig_custom_alpha' && op !== 'autokey_custom_alpha'){
    hideProgress();
    return testCribs(); // call the original
  }

  function minimalPeriod(arr){
    const n = arr.length;
    for (let p=1; p<=n; p++){
      if (n % p !== 0) continue;
      let ok=true;
      for (let i=0;i<n;i++){ if (arr[i] !== arr[i%p]){ ok=false; break; } }
      if (ok) return p;
    }
    return n;
  }
  const {letters, cribMap} = gatherCribs();
  const segments = collectContiguousCribs(letters, cribMap);
  const minK = parseInt(document.getElementById('minK').value);
  const maxK = parseInt(document.getElementById('maxK').value);
  const out = document.getElementById('out');
  out.textContent='';
  if (segments.length === 0){ setSummaryMessage('Enter at least one crib segment.'); return; }
  const total = (maxK - minK + 1);
  const isVigMode = (op === 'vig_custom_alpha');
  const autokeyAlgo = currentAutokeyAlgo();
  const autokeyLabel = autokeyAlgoLabel(autokeyAlgo);
  showProgress(total);
  const results=[];
  const coveragePerM = [];
  for (let kLen=minK; kLen<=maxK; kLen++){
    let coverage = null;
    if (!isVigMode){
      coverage = autokeyCoverageDiagnostics(letters, cribMap, kLen);
      coveragePerM.push({ m: kLen, coverage });
    }
    const sol = isVigMode
      ? solveVigUnknownAlphabet(letters, cribMap, kLen)
      : solveAutokeyUnknownAlphabet(letters, cribMap, kLen, undefined, autokeyAlgo);
    if (sol){
      const dec = isVigMode
        ? decryptWithCustomAlphabet(letters, sol.pos, sol.k)
        : decryptAutokeyUnknownAlphabet(letters, sol.pos, sol.k, autokeyAlgo);
      const fitness = englishFitness( sanitize(dec).split('') );
      const alphaInfo = alphabetInfoFromPositions(sol.pos);
      const keyResidues = sol.k.map(x=>A[x]).join('');
      const actualKey = sol.k.map(v => alphaInfo.inv[v] || '?').join('');
      results.push({
        keyLength:kLen,
        key: keyResidues,
        actualKey: isVigMode ? null : actualKey,
        alphabet: alphaInfo.invString,
        preview: dec.slice(0,160),
        score: fitness,
        posRaw: sol.pos,
        kRaw: sol.k
      });
    }
    updateProgress(kLen - minK + 1);
    if ((kLen - minK) % 1 === 0) await uiYield();
  }
  hideProgress();

  if (!results.length){
    if (isVigMode){
      // Build a quick debug: report constraints coverage and contradictions per m
      let debugLines = [];
      for (let kLen=minK; kLen<=maxK; kLen++){
        const { cLetters, absToLetterStep } = buildLetterStreams(letters);
        const stepToAbs = [];
        for (let ai=0; ai<letters.length; ai++){ const s = absToLetterStep[ai]; if (s>=0) stepToAbs[s]=ai; }
        const cons=[];
        for (let i=0;i<letters.length;i++){
          if (!isLetter(letters[i])) continue;
          const baseStep = absToLetterStep[i];
          const cribRaw = cribMap[i];
          if (!cribRaw) continue;
          const cribLetters = sanitize(cribRaw);
          for (let j=0; j<cribLetters.length; j++){
            const p = cribLetters[j];
            if (!/[A-Z]/.test(p)) continue;
            const step = baseStep + j;
            const absIdx = stepToAbs[step];
            if (absIdx === undefined) break;
            const c = letters[absIdx].toUpperCase();
            if (!/[A-Z]/.test(c)) continue;
            cons.push({ r: step % kLen, pSym: A2I[p], cSym: A2I[c] });
          }
        }
        const byR = Array.from({length:kLen},()=>[]); cons.forEach(c=>byR[c.r].push(c));
        let cover = byR.filter(g=>g.length>0).length;
        const contrad = false;
        debugLines.push(`m=${kLen}: constraints=${cons.length}, residuesHit=${cover}/${kLen}, contradictions=${contrad}`);
      }
      setSummaryMessage(`No solution for key lengths ${minK}..${maxK} under this model.`, { noResult: true });
      const pre = document.createElement('pre'); pre.className='small muted'; pre.textContent = debugLines.join('\n');
      out.appendChild(pre);
    } else {
      setSummaryMessage(`No solution for key lengths ${minK}..${maxK} under autokey + unknown alphabet (${autokeyLabel}).`, { noResult: true });
      const pre = document.createElement('pre'); pre.className='small muted';
      const detailLines = [];
      for (const {m, coverage} of coveragePerM){
        if (!coverage) continue;
        const missing = coverage.missingFeed.length;
        const feed = coverage.feedLinks;
        const residues = coverage.residues.map((cnt, idx)=>`${idx}:${cnt}`).join(', ');
        detailLines.push(`m=${m}: crib steps=${coverage.totalSteps}, feed links=${feed}, missing feed=${missing}, residues {${residues}}`);
        if (missing>0){
          const sample = coverage.missingFeed.slice(0,5).map(({step, dependsOn})=>`(${step}<-${dependsOn})`).join(' ');
          if (sample) detailLines.push(`  uncovered autokey links: ${sample}${coverage.missingFeed.length>5?' …':''}`);
        }
        const byR = Array.from({length:kLen},()=>[]); cons.forEach(c=>byR[c.r].push(c));
        let cover = byR.filter(g=>g.length>0).length;
        const contrad = false;
        debugLines.push(`m=${kLen}: constraints=${cons.length}, residuesHit=${cover}/${kLen}, contradictions=${contrad}`);
      }
      if (detailLines.length){
        pre.textContent = detailLines.join('\n');
      } else {
        pre.textContent = 'Autokey mode relies on chained crib coverage (positions spaced by the key length). Try adding overlapping cribs or narrowing the key-length range.';
      }
      out.appendChild(pre);
    }
    return;
  }
  results.sort((a,b)=>b.score - a.score);
// --- Injected: display best full decrypt & recovered alphabet for unknown alphabet mode ---
try{
  if (Array.isArray(results) && results.length){
    results.sort((a,b)=>b.score - a.score);
    const best = results[0];
    if (best && best.posRaw && best.kRaw){
      const alphaInfo = alphabetInfoFromPositions(best.posRaw);
      const alphaStr = alphaInfo.invString;
      const fullText = isVigMode
        ? decryptWithCustomAlphabet(letters, best.posRaw, best.kRaw)
        : decryptAutokeyUnknownAlphabet(letters, best.posRaw, best.kRaw, autokeyAlgo);
      const displayKey = isVigMode ? best.key : best.kRaw.map(v => alphaInfo.inv[v] || '?').join('');
      const residuesLine = (!isVigMode && best.key) ? `key residues: ${best.key}\n` : '';
      const fullBlock = document.createElement('pre');
      fullBlock.textContent =
        `Best candidate (m=${best.keyLength})\n` +
        `initial key: ${displayKey}\n` +
        residuesLine +
        `alphabet:    ${alphaStr}\n\n` +
        fullText;
      out.appendChild(fullBlock);
    }
  }
}catch(e){ console.warn('Summary render failed', e); }

  setSummaryMessage(
    isVigMode
      ? `Found ${results.length} solution(s) for unknown alphabet Vigenère.`
      : `Found ${results.length} solution(s) for autokey + unknown alphabet (${autokeyLabel}).`
  );
  results.slice(0,50).forEach((r,idx)=>{
    const div=document.createElement('div'); div.className='row';
    const keyDisplay = (!isVigMode && r.actualKey) ? r.actualKey : r.key;
    const residuesInfo = (!isVigMode && r.actualKey && r.actualKey !== r.key) ? ` (residues ${r.key})` : '';
    const head=document.createElement('div'); head.textContent = `#${idx+1}  m=${r.keyLength}  initialKey=${keyDisplay}${residuesInfo}`;
    const body=document.createElement('div'); body.className='small muted'; body.textContent=r.preview;
    div.appendChild(head); div.appendChild(body); out.appendChild(div);
  });
}
</script>

  </div>
    <div id="uaWorkerStatus" style="font-family:monospace;margin-top:6px;opacity:0.85"></div>
<div id="uaCandidatesBox" class="small muted" style="margin-top:4px;">Found so far: <span id="uaCandidatesCount">0</span> candidate(s)</div>

    <pre id="uaWorkerResult" style="white-space:pre-wrap"></pre>
  </div>


  <script>
  (function(){
    function $(id){ return document.getElementById(id); }
    const BTN_TEST = $("test");
    const BTN_STOP = $("stopSearch");
    const SEL_OP   = $("op");
    const SEL_AUTOKEY_ALGO = $("autokeyAlgo");
    const LBL_AUTOKEY_ALGO = $("autokeyAlgoLabel");
    const OUT      = $("out");
    const SUMMARY  = $("summary");
    const CAND_CNT = $("uaCandidatesCount");
    const BTN_BRUTE = $("bruteForce");
    const BRUTE_PANEL = $("bruteResults");
    const BRUTE_SUMMARY = $("bruteSummary");
    const BRUTE_OUT = $("bruteOut");

    const DEFAULT_MIN_K = 4;
    const DEFAULT_MAX_K = 20;

    if (SEL_OP){
      SEL_OP.value = 'autokey_custom_alpha';
      SEL_OP.disabled = true;
    }
    const MIN_K_INPUT = $("minK");
    const MAX_K_INPUT = $("maxK");
    if (MIN_K_INPUT){
      MIN_K_INPUT.value = DEFAULT_MIN_K;
      MIN_K_INPUT.disabled = true;
    }
    if (MAX_K_INPUT){
      MAX_K_INPUT.value = DEFAULT_MAX_K;
      MAX_K_INPUT.disabled = true;
    }
    if (SEL_AUTOKEY_ALGO){
      SEL_AUTOKEY_ALGO.value = normalizeAutokeyAlgo(SEL_AUTOKEY_ALGO.value);
    }
    updateAutokeyAlgoVisibility();
    resetHeatMeter();

    let uaWorker = null;
    let currentJob = null;
    let bruteCtx = null;

    const AUTO_STOP_MS = 15000;
    const AUTO_STOP_MESSAGE = "Hmm… I need a little more information to confirm this one — try adding more crib letters and test again!";
    let autoStopTimer = null;

    function clearAutoStopTimer(){
      if (autoStopTimer){
        clearTimeout(autoStopTimer);
        autoStopTimer = null;
      }
    }

    function scheduleAutoStop(){
      clearAutoStopTimer();
      autoStopTimer = setTimeout(() => {
        stopWorker(AUTO_STOP_MESSAGE, '');
        if (SUMMARY){
          setSummaryMessage(AUTO_STOP_MESSAGE, { noResult: true });
        }
      }, AUTO_STOP_MS);
    }

    function updateAutokeyAlgoVisibility(){
      if (!SEL_AUTOKEY_ALGO) return;
      const op = SEL_OP ? SEL_OP.value : '';
      const show = op === 'autokey_custom_alpha';
      SEL_AUTOKEY_ALGO.style.display = show ? '' : 'none';
      if (LBL_AUTOKEY_ALGO) LBL_AUTOKEY_ALGO.style.display = show ? '' : 'none';
      if (!show && SEL_AUTOKEY_ALGO){
        SEL_AUTOKEY_ALGO.value = normalizeAutokeyAlgo(SEL_AUTOKEY_ALGO.value);
      }
    }

    function gatherForWorker(){
      const letters = ($("ctext") ? $("ctext").value : "").split("");
      const inputs = document.querySelectorAll("input.cribin");
      const cribPairs = [];
      inputs.forEach(inp => {
        const v = (inp.value || "").toUpperCase().replace(/[^A-Z]/g,"");
        if (!v) return;
        const pos = parseInt(inp.dataset.pos);
        if (!Number.isFinite(pos)) return;
        const letter = v[0];
        if (!letter) return;
        cribPairs.push([pos, letter]);
      });
      if (MIN_K_INPUT) MIN_K_INPUT.value = DEFAULT_MIN_K;
      if (MAX_K_INPUT) MAX_K_INPUT.value = DEFAULT_MAX_K;
      const minK = DEFAULT_MIN_K;
      const maxK = DEFAULT_MAX_K;
      const op = SEL_OP ? SEL_OP.value : '';
      return { letters, cribPairs, minK, maxK, op, autokeyAlgo: currentAutokeyAlgo() };
    }

    function makeWorker(){
      const src = `let __candsFound = 0;
        let __cancelled = false;

        const A = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const A2I = {}; for (let i=0;i<26;i++) A2I[A[i]] = i;
        function isLetter(ch){ return ch && /[A-Za-z]/.test(ch); }
        function sanitize(s){ return (s||'').toUpperCase().replace(/[^A-Z]/g,''); }
        function buildLetterStreams(letters){
          const cLetters = [];
          const absToLetterStep = new Array(letters.length).fill(-1);
          let step = 0;
          for (let i=0;i<letters.length;i++){
            const ch = letters[i];
            if (isLetter(ch)){ cLetters.push(ch.toUpperCase()); absToLetterStep[i]=step++; }
          }
          return { cLetters, absToLetterStep };
        }
        function collectContiguousCribs(letters, cribMap){
          const segments = [];
          const isAZ = ch => /^[A-Za-z]$/.test(ch || '');
          let i = 0;
          while (i < letters.length){
            if (!isLetter(letters[i])){ i++; continue; }
            if (cribMap[i] && isAZ(cribMap[i])){
              let j=i;
              let cipherSeg='', plainSeg='';
              while (j < letters.length && isLetter(letters[j]) && cribMap[j] && isAZ(cribMap[j])){
                cipherSeg += letters[j].toUpperCase();
                plainSeg  += (cribMap[j] + '').toUpperCase();
                j++;
              }
              const cSan = sanitize(cipherSeg);
              const pSan = sanitize(plainSeg);
              if (cSan.length > 0 && pSan.length === cSan.length){
                segments.push({ start:i, cipherSeg:cSan, plainSeg:pSan });
              }
              i=j;
            } else i++;
          }
          return segments;
        }
        function englishFitness(upArr){
          const FREQ = {'E':12.0,'T':9.1,'A':8.2,'O':7.5,'I':7.0,'N':6.7,'S':6.3,'R':6.0,'H':6.1,'L':4.0,'D':4.3,'C':2.8,'U':2.8,'M':2.4,'F':2.2,'Y':2.0,'W':2.4,'G':2.0,'P':1.9,'B':1.5,'V':1.0,'K':0.8,'X':0.2,'Q':0.1,'J':0.15,'Z':0.07};
          const n = upArr.length||1;
          const cnt={}; for (const ch of upArr){ cnt[ch]=(cnt[ch]||0)+1; }
          let chi=0; for (const ch of A){ const obs=(cnt[ch]||0); const exp=FREQ[ch]*n/100; if (exp>0) chi += (obs-exp)*(obs-exp)/exp; }
          return -chi;
        }
        function buildAlphabetString(pos){
          const N=26;
          const posFull = pos.slice();
          const taken = new Array(N).fill(false);
          for (let L=0; L<N; L++){ if (posFull[L]!=null){ taken[posFull[L]]=true; } }
          let t=0;
          for (let L=0; L<N; L++){
            if (posFull[L]==null){
              while(t<N && taken[t]) t++;
              if (t<N){ posFull[L]=t; taken[t]=true; }
            }
          }
          const inv = new Array(N);
          for (let L=0; L<N; L++){ const idx = posFull[L]; if (idx!=null && idx>=0 && idx<N){ inv[idx] = A[L]; } }
          for (let i=0;i<N;i++){ if (!inv[i]) inv[i] = A[i]; }
          return { posFull, inv, invString: inv.join('') };
        }
        const AUTOKEY_ALGOS = ['vigenere','beaufort','beaufort_variant'];
        function normalizeAutokeyAlgo(value){
          if (value === 'beaufort' || value === 'beaufort_variant') return value;
          return 'vigenere';
        }
        function autokeyOpsFor(algo){
          const norm = normalizeAutokeyAlgo(algo);
          if (norm === 'beaufort'){
            return {
              keyFromPlainCipher: (p, c) => c + p,
              cipherFromPlainKey: (p, k) => k - p,
              plainFromCipherKey: (c, k) => k - c
            };
          }
          if (norm === 'beaufort_variant'){
            return {
              keyFromPlainCipher: (p, c) => p - c,
              cipherFromPlainKey: (p, k) => p - k,
              plainFromCipherKey: (c, k) => c + k
            };
          }
          return {
            keyFromPlainCipher: (p, c) => c - p,
            cipherFromPlainKey: (p, k) => p + k,
            plainFromCipherKey: (c, k) => c - k
          };
        }
        function solveVigUnknownAlphabet(letters, cribMap, m, progressCb){
          const N=26;
          const segments = collectContiguousCribs(letters, cribMap);
          const { cLetters, absToLetterStep } = buildLetterStreams(letters);
          const cons=[];
          for (const seg of segments){
            let letterIdx=-1;
            for (let i=0, seen=0; i<letters.length; i++){
              if (isLetter(letters[i])){
                if (i === seg.start){ letterIdx=seen; break; }
                seen++;
              }
            }
            if (letterIdx < 0) continue;
            for (let t=0; t<seg.cipherSeg.length; t++){
              const pSym = A2I[seg.plainSeg[t]];
              const cSym = A2I[seg.cipherSeg[t]];
              const r = (letterIdx + t) % m;
              cons.push({ r, pSym, cSym });
            }
          }
          if (!cons.length) return null;
          const byR = Array.from({length:m},()=>[]);
          cons.forEach(c => byR[c.r].push(c));
          const pos = new Array(N).fill(null);
          const used = new Array(N).fill(false);
          const k   = new Array(m).fill(null);
          const deg = new Array(N).fill(0);
          for (const {pSym,cSym} of cons){ deg[pSym]++; deg[cSym]++; }
          let anchor=-1, best=-1;
          for (let L=0; L<N; L++){ if (deg[L]>best){ best=deg[L]; anchor=L; } }
          if (anchor!==-1){ pos[anchor]=0; used[0]=true; }
          const mod = (x)=>((x%26)+26)%26;
          function propagate(){
            let changed=true;
            while(changed){
              changed=false;
              for (const {r,pSym,cSym} of cons){
                const a=pos[pSym], b=pos[cSym];
                if (a!==null && b!==null){
                  const need=mod(b-a);
                  if (k[r]===null){ k[r]=need; changed=true; }
                  else if (k[r]!==need) return false;
                } else if (k[r]!==null){
                  if (a!==null && b===null){
                    const need=mod(a+k[r]);
                    if (used[need] && pos[cSym]!==need) return false;
                    if (pos[cSym]===null){ pos[cSym]=need; used[need]=true; changed=true; }
                    else if (pos[cSym]!==need) return false;
                  } else if (a===null && b!==null){
                    const need=mod(b-k[r]);
                    if (used[need] && pos[pSym]!==need) return false;
                    if (pos[pSym]===null){ pos[pSym]=need; used[need]=true; changed=true; }
                    else if (pos[pSym]!==need) return false;
                  }
                }
              }
              const seen = new Set();
              for (let L=0; L<N; L++){
                const v = pos[L];
                if (v===null) continue;
                if (seen.has(v)) return false;
                seen.add(v);
              }
            }
            return true;
          }
          function chooseVar(){
            let rr=-1, best=-1;
            for (let r=0;r<m;r++){ if (k[r]===null && byR[r].length>best){best=byR[r].length; rr=r;} }
            if (rr!==-1) return {type:'r', idx:rr};
            const appear=new Set(); cons.forEach(({pSym,cSym})=>{appear.add(pSym); appear.add(cSym);});
            const counts=new Array(N).fill(0); cons.forEach(({pSym,cSym})=>{counts[pSym]++; counts[cSym]++;});
            let bestL=-1, b=-1;
            for (let L=0; L<26; L++){ if (!appear.has(L)) continue; if (pos[L]===null && counts[L]>b){ b=counts[L]; bestL=L; } }
            if (bestL!==-1) return {type:'p', idx:bestL};
            return null;
          }
          function snap(){ return { pos: pos.slice(), used: used.slice(), k: k.slice() }; }
          function restore(S){ for (let i=0;i<26;i++){ pos[i]=S.pos[i]; used[i]=S.used[i]; } for (let i=0;i<m;i++){ k[i]=S.k[i]; } }
          let nodes=0, lastPing=0;
          function dfs(){
            if (!propagate()) return null;
            const sel = chooseVar();
            if (!sel){
              const posFull = pos.slice();
              const free=[]; for (let v=0; v<26; v++){ if (!used[v]) free.push(v); }
              for (let L=0; L<26; L++){ if (posFull[L]===null) posFull[L]=free.shift(); }
              const key = k.map(x=>x===null?0:x);
              return { pos: posFull, k: key };
            }
            nodes++;
            const now = (typeof performance!=='undefined'?performance.now():0);
            if (now - lastPing > 120){ lastPing = now; progressCb && progressCb({kind:'dfs', nodes}); }
            if (sel.type === 'r'){
              const r = sel.idx;
              let cand=null;
              for (const {pSym,cSym} of byR[r]){
                if (pos[pSym]!==null && pos[cSym]!==null){ cand=[mod(pos[cSym]-pos[pSym])]; break; }
              }
              if (!cand){
                const diffs=new Set();
                const g = byR[r];
                for (let i=0;i<g.length;i++){
                  for (let j=i+1;j<g.length;j++){
                    const a=g[i], b=g[j];
                    if (a.pSym===b.pSym){
                      const p=a.pSym;
                      if (pos[p]!==null && pos[a.cSym]!==null) diffs.add(mod(pos[a.cSym]-pos[p]));
                      if (pos[p]!==null && pos[b.cSym]!==null) diffs.add(mod(pos[b.cSym]-pos[p]));
                    }
                    if (a.cSym===b.cSym){
                      const c=a.cSym;
                      if (pos[c]!==null && pos[a.pSym]!==null) diffs.add(mod(pos[c]-pos[a.pSym]));
                      if (pos[c]!==null && pos[b.pSym]!==null) diffs.add(mod(pos[c]-pos[b.pSym]));
                    }
                  }
                }
                cand = diffs.size ? Array.from(diffs) : [...Array(26).keys()];
              }
              for (const val of cand){
                const S = snap(); k[r]=val;
                const res = dfs(); if (res) return res;
                restore(S);
              }
              return null;
            } else {
              const L = sel.idx;
              const free=[]; for (let v=0; v<26; v++){ if (!used[v]) free.push(v); }
              for (const v of free){
                const S = snap(); pos[L]=v; used[v]=true;
                const res = dfs(); if (res) return res;
                restore(S);
              }
              return null;
            }
          }
          return dfs();
        }
        function decryptWithCustomAlphabet(letters, pos, k){
          const inv = new Array(26); for (let L=0; L<26; L++) inv[pos[L]] = String.fromCharCode(65+L);
          let out=''; let step=0;
          for (let i=0;i<letters.length;i++){
            const ch=letters[i];
            if (!isLetter(ch)){ out+=ch; continue; }
            const cIdx = pos[ch.toUpperCase().charCodeAt(0)-65];
            const pIdx = ((cIdx - k[step % k.length]) % 26 + 26) % 26;
            out += inv[pIdx];
            step++;
          }
          return out;
        }
        function solveAutokeyUnknownAlphabet(letters, cribMap, m, options, algo){
          const opts = (options && typeof options === 'object') ? options : null;
          if (opts){
            opts.timedOut = false;
            opts.visitedNodes = 0;
          }
          const N = 26;
          let timedOut = false;
          let nodeVisits = 0;
          const maxMillis = (opts && Number.isFinite(opts.maxMillis) && opts.maxMillis > 0) ? opts.maxMillis : null;
          const maxNodes = (opts && Number.isFinite(opts.maxNodes) && opts.maxNodes > 0) ? opts.maxNodes|0 : null;
          const timeFn = (typeof performance !== 'undefined' && typeof performance.now === 'function')
            ? () => performance.now()
            : () => Date.now();
          const hasTimeLimit = maxMillis !== null;
          const startTime = hasTimeLimit ? timeFn() : 0;
          function limitReached(){
            if (__cancelled) return true;
            if (timedOut) return true;
            if (hasTimeLimit && (timeFn() - startTime) >= maxMillis){
              timedOut = true;
              return true;
            }
            if (maxNodes !== null && nodeVisits >= maxNodes){
              timedOut = true;
              return true;
            }
            return false;
          }
          if (!Number.isFinite(m) || m <= 0) return null;
          const segments = collectContiguousCribs(letters, cribMap);
          if (!segments.length) return null;
          const { absToLetterStep } = buildLetterStreams(letters);
          const stepPlain = new Map();
          const stepCipher = new Map();
          for (const seg of segments){
            const startStep = absToLetterStep[seg.start];
            if (startStep == null || startStep < 0) continue;
            for (let t=0; t<seg.cipherSeg.length; t++){
              const step = startStep + t;
              const pSym = A2I[seg.plainSeg[t]];
              const cSym = A2I[seg.cipherSeg[t]];
              if (stepPlain.has(step) && stepPlain.get(step) !== pSym) return null;
              if (stepCipher.has(step) && stepCipher.get(step) !== cSym) return null;
              stepPlain.set(step, pSym);
              stepCipher.set(step, cSym);
            }
          }
          if (!stepPlain.size) return null;
        
          const constraints = [];
          const letterDeg = new Array(N).fill(0);
          const keyDeg = new Array(m).fill(0);
          const steps = Array.from(stepPlain.keys()).sort((a,b)=>a-b);
          for (const step of steps){
            const pSym = stepPlain.get(step);
            const cSym = stepCipher.get(step);
            if (pSym == null || cSym == null) continue;
            if (step < m){
              constraints.push({ type:'init', idx:step, pSym, cSym });
              keyDeg[step]++;
            }
            const depStep = step - m;
            if (depStep >= 0 && stepPlain.has(depStep)){
              const depSym = stepPlain.get(depStep);
              constraints.push({ type:'feed', idx:step, pSym, cSym, depSym });
              letterDeg[depSym]++;
            }
            letterDeg[pSym]++;
            letterDeg[cSym]++;
          }
          if (!constraints.length) return null;
        
          const pos = new Array(N).fill(null);
          const used = new Array(N).fill(false);
          const keyInit = new Array(m).fill(null);
        
          const mod = (x)=>((x%N)+N)%N;
          const algorithm = normalizeAutokeyAlgo(algo);
          const ops = autokeyOpsFor(algorithm);
          const keyFromPlainCipher = (p, c) => mod(ops.keyFromPlainCipher(p, c));
          const cipherFromPlainKey = (p, k) => mod(ops.cipherFromPlainKey(p, k));
          const plainFromCipherKey = (c, k) => mod(ops.plainFromCipherKey(c, k));
        
          function assignLetter(idx, value){
            if (idx == null) return {ok:true, changed:false};
            value = mod(value);
            if (pos[idx] === null){
              if (used[value]) return {ok:false, changed:false};
              pos[idx] = value;
              used[value] = true;
              return {ok:true, changed:true};
            }
            return {ok: pos[idx] === value, changed:false};
          }
        
          function assignKey(idx, value){
            value = mod(value);
            if (keyInit[idx] === null){
              keyInit[idx] = value;
              return {ok:true, changed:true};
            }
            return {ok: keyInit[idx] === value, changed:false};
          }
        
          function propagate(){
            let changed = true;
            while (changed){
              if (limitReached()) return false;
              changed = false;
              for (const cons of constraints){
                if (limitReached()) return false;
                if (cons.type === 'init'){
                  const a = pos[cons.pSym];
                  const b = pos[cons.cSym];
                  const keyVal = keyInit[cons.idx];
                  if (a !== null && b !== null){
                    const res = assignKey(cons.idx, keyFromPlainCipher(a, b));
                    if (!res.ok) return false;
                    if (res.changed) changed = true;
                  }
                  if (a !== null && keyVal !== null){
                    const res = assignLetter(cons.cSym, cipherFromPlainKey(a, keyVal));
                    if (!res.ok) return false;
                    if (res.changed) changed = true;
                  }
                  if (b !== null && keyVal !== null){
                    const res = assignLetter(cons.pSym, plainFromCipherKey(b, keyVal));
                    if (!res.ok) return false;
                    if (res.changed) changed = true;
                  }
                } else {
                  const a = pos[cons.pSym];
                  const b = pos[cons.cSym];
                  const dep = pos[cons.depSym];
                  if (a !== null && dep !== null){
                    const res = assignLetter(cons.cSym, cipherFromPlainKey(a, dep));
                    if (!res.ok) return false;
                    if (res.changed) changed = true;
                  }
                  const bNow = pos[cons.cSym];
                  const aNow = pos[cons.pSym];
                  const depNow = pos[cons.depSym];
                  if (bNow !== null && aNow !== null){
                    const res = assignLetter(cons.depSym, keyFromPlainCipher(aNow, bNow));
                    if (!res.ok) return false;
                    if (res.changed) changed = true;
                  }
                  if (bNow !== null && depNow !== null){
                    const res = assignLetter(cons.pSym, plainFromCipherKey(bNow, depNow));
                    if (!res.ok) return false;
                    if (res.changed) changed = true;
                  }
                }
              }
            }
            if (limitReached()) return false;
            return true;
          }
        
          function chooseVar(){
            let bestLetter=-1, bestScore=-1;
            for (let L=0; L<N; L++){
              if (pos[L]===null && letterDeg[L]>bestScore){
                bestScore = letterDeg[L];
                bestLetter = L;
              }
            }
            if (bestLetter !== -1 && bestScore>0) return {type:'letter', idx:bestLetter};
            let bestKey=-1, bestKeyScore=-1;
            for (let i=0;i<m;i++){
              if (keyInit[i]===null && keyDeg[i]>bestKeyScore){
                bestKeyScore = keyDeg[i];
                bestKey = i;
              }
            }
            if (bestKey !== -1 && bestKeyScore>0) return {type:'key', idx:bestKey};
            return null;
          }
        
          function snapshot(){
            return { pos: pos.slice(), used: used.slice(), key: keyInit.slice() };
          }
          function restore(state){
            for (let i=0;i<N;i++){ pos[i]=state.pos[i]; used[i]=state.used[i]; }
            for (let i=0;i<m;i++){ keyInit[i]=state.key[i]; }
          }
        
          function dfs(){
            if (limitReached()) return null;
            nodeVisits++;
            if (limitReached()) return null;
            if (!propagate()) return null;
            if (limitReached()) return null;
            const sel = chooseVar();
            if (!sel){
              const posFull = pos.slice();
              const free = [];
              for (let v=0; v<N; v++){ if (!used[v]) free.push(v); }
              for (let L=0; L<N; L++){ if (posFull[L]===null) posFull[L] = free.shift(); }
              const keyFull = keyInit.slice().map(x => x===null ? 0 : mod(x));
              return { pos: posFull, k: keyFull };
            }
            if (sel.type === 'letter'){
              const candSet = new Set();
              for (const cons of constraints){
                if (cons.pSym === sel.idx){
                  if (cons.type === 'init'){
                    const b = pos[cons.cSym];
                    const keyVal = keyInit[cons.idx];
                    if (b !== null && keyVal !== null) candSet.add(plainFromCipherKey(b, keyVal));
                  } else {
                    const b = pos[cons.cSym];
                    const dep = pos[cons.depSym];
                    if (b !== null && dep !== null) candSet.add(plainFromCipherKey(b, dep));
                  }
                }
                if (cons.cSym === sel.idx){
                  if (cons.type === 'init'){
                    const a = pos[cons.pSym];
                    const keyVal = keyInit[cons.idx];
                    if (a !== null && keyVal !== null) candSet.add(cipherFromPlainKey(a, keyVal));
                  } else {
                    const a = pos[cons.pSym];
                    const dep = pos[cons.depSym];
                    if (a !== null && dep !== null) candSet.add(cipherFromPlainKey(a, dep));
                  }
                }
                if (cons.type === 'feed' && cons.depSym === sel.idx){
                  const a = pos[cons.pSym];
                  const b = pos[cons.cSym];
                  if (b !== null && a !== null) candSet.add(keyFromPlainCipher(a, b));
                }
              }
              const free = [];
              for (let v=0; v<N; v++){ if (!used[v]) free.push(v); }
              const candidates = candSet.size ? Array.from(candSet).filter(v => !used[v]) : free;
              for (const val of candidates){
                const snap = snapshot();
                const vv = mod(val);
                pos[sel.idx] = vv;
                used[vv] = true;
                const res = dfs();
                if (res) return res;
                if (timedOut) return null;
                restore(snap);
              }
            } else {
              const candSet = new Set();
              for (const cons of constraints){
                if (cons.type === 'init' && cons.idx === sel.idx){
                  const a = pos[cons.pSym];
                  const b = pos[cons.cSym];
                  if (a !== null && b !== null) candSet.add(keyFromPlainCipher(a, b));
                }
              }
              const candidates = candSet.size ? Array.from(candSet) : [...Array(N).keys()];
              for (const val of candidates){
                const snap = snapshot();
                keyInit[sel.idx] = mod(val);
                const res = dfs();
                if (res) return res;
                if (timedOut) return null;
                restore(snap);
              }
            }
            return null;
          }
        
          if (options && options.propagateOnly){
            return propagate();
          }
        
          const solved = dfs();
          if (opts){
            opts.timedOut = timedOut;
            opts.visitedNodes = nodeVisits;
          }
          return solved;
        }
        function decryptAutokeyUnknownAlphabet(letters, pos, keyInit, algo){
          const N = 26;
          const inv = new Array(N); for (let L=0; L<N; L++) inv[pos[L]] = String.fromCharCode(65+L);
          const plainPositions = [];
          let step = 0;
          let out = '';
          const mod = (x)=>((x%N)+N)%N;
          const algorithm = normalizeAutokeyAlgo(algo);
          const ops = autokeyOpsFor(algorithm);
          const plainFromCipherKey = (c, k) => mod(ops.plainFromCipherKey(c, k));
          for (let i=0; i<letters.length; i++){
            const ch = letters[i];
            if (!isLetter(ch)){ out += ch; continue; }
            const cIdx = pos[ch.toUpperCase().charCodeAt(0)-65];
            let keyVal;
            if (step < keyInit.length){
              keyVal = keyInit[step];
            } else {
              keyVal = plainPositions[step - keyInit.length];
            }
            if (keyVal == null) keyVal = 0;
            keyVal = mod(keyVal);
            const pIdx = plainFromCipherKey(cIdx, keyVal);
            plainPositions.push(pIdx);
            out += inv[pIdx];
            step++;
          }
          return out;
        }
        function solveCribVigenere(cipherSeg, plainSeg, keylen, letterStartPos){
          const tpl = Array(keylen).fill(null);
          for (let t=0; t<cipherSeg.length; t++){
            const c = A2I[cipherSeg[t]];
            const p = A2I[plainSeg[t]];
            const kpos = (letterStartPos + t) % keylen;
            const need = ((c - p) % 26 + 26) % 26;
            if (tpl[kpos] === null) tpl[kpos] = need;
            else if (tpl[kpos] !== need) return { ok:false, template:null };
          }
          return { ok:true, template: tpl };
        }
        function applyVigenereDecrypt(letters, template){
          const keylen = template.length;
          let out = '';
          let step = 0;
          for (let i=0; i<letters.length; i++){
            const ch = letters[i];
            if (!isLetter(ch)){ out += ch; continue; }
            const c = A2I[ch.toUpperCase()];
            const kv = template[step % keylen];
            let pCh = '?';
            if (kv !== null){
              const p = ((c - kv) % 26 + 26) % 26;
              pCh = A[p];
            }
            out += pCh;
            step++;
          }
          return out;
        }
        function solveMASVigDeterministic(cLetters, constraints, minK, maxK){
          const results=[];
          function fillPerm(p){ const used=new Set(p.filter(v=>v!==null)); const rem=[]; for(let v=0; v<26; v++) if(!used.has(v)) rem.push(v); const out=p.slice(); for(let i=0;i<26;i++){ if(out[i]===null) out[i]=rem.shift(); } return out; }
          function invertPerm(p){ const inv=new Array(26); for(let i=0;i<26;i++){ inv[p[i]] = i; } return inv; }
          for (let m=minK; m<=maxK; m++){
            const s = new Array(26).fill(null);
            const k = new Array(m).fill(null);
            const cons = constraints.map(o=>({ r: o.pos % m, cIdx:o.cIdx, pIdx:o.pIdx }));
            function propagate(){
              let changed=true;
              while (changed){
                changed=false;
                for (const {r,cIdx,pIdx} of cons){
                  if (k[r]!==null && s[pIdx]===null){ const val=((cIdx - k[r])%26+26)%26; if (s[pIdx]===null){ s[pIdx]=val; changed=true; } else if (s[pIdx]!==val){ return false; } }
                  if (s[pIdx]!==null && k[r]===null){ const val=((cIdx - s[pIdx])%26+26)%26; if (k[r]===null){ k[r]=val; changed=true; } else if (k[r]!==val){ return false; } }
                  if (s[pIdx]!==null && k[r]!==null){ if ( ((cIdx - s[pIdx])%26+26)%26 !== k[r]) return false; }
                }
                const seen=new Set();
                for (let i=0;i<26;i++){ const v=s[i]; if (v===null) continue; if (seen.has(v)) return false; seen.add(v); }
              }
              return true;
            }
            function dfs(){
              if (!propagate()) return null;
              if (k.every(v=>v!==null)) return {s:s.slice(), k:k.slice()};
              const counts = new Array(m).fill(0); cons.forEach(({r})=>counts[r]++);
              let rr = -1, best=-1;
              for (let r=0;r<m;r++){ if (k[r]===null && counts[r]>best){best=counts[r]; rr=r;} }
              if (rr<0) return {s:s.slice(), k:k.slice()};
              let cand = null;
              for (const {r,cIdx,pIdx} of cons){ if (r===rr && s[pIdx]!==null){ cand = [ ((cIdx - s[pIdx])%26+26)%26 ]; break; } }
              if (!cand){ cand = [...Array(26).keys()]; }
              for (const val of cand){
                const old = k[rr]; k[rr]=val;
                const res = dfs(); if (res) return res;
                k[rr]=old;
              }
              return null;
            }
            const sol = dfs();
            if (sol){
              const S = fillPerm(sol.s);
              const Sinv = invertPerm(S);
              const dec = [];
              for (let i=0;i<cLetters.length;i++){ const c=A2I[cLetters[i]]; const p = Sinv[ ((c - sol.k[i % m])%26+26)%26 ]; dec.push(A[p]); }
              results.push({m, key:sol.k, subInv:Sinv, plaintext:dec.join('')});
            }
          }
          return results.sort((a,b)=>b.plaintext.length-a.plaintext.length);
        }
        function solveCipherSubDeterministic(cLetters, constraints, minK, maxK){
          const results=[];
          function fillPerm(p){ const used=new Set(p.filter(v=>v!==null)); const rem=[]; for(let v=0; v<26; v++) if(!used.has(v)) rem.push(v); const out=p.slice(); for(let i=0;i<26;i++){ if(out[i]===null) out[i]=rem.shift(); } return out; }
          for (let m=minK; m<=maxK; m++){
            const pMap = new Array(26).fill(null);
            const k = new Array(m).fill(null);
            const cons = constraints.map(o=>({ r:o.pos % m, cIdx:o.cIdx, pIdx:o.pIdx }));
            function propagate(){
              let changed=true;
              while (changed){
                changed=false;
                for (const {r,cIdx,pIdx} of cons){
                  if (k[r]!==null && pMap[cIdx]===null){ const val=((pIdx + k[r])%26+26)%26; if (pMap[cIdx]===null){ pMap[cIdx]=val; changed=true; } else if (pMap[cIdx]!==val){ return false; } }
                  if (pMap[cIdx]!==null && k[r]===null){ const val=((pMap[cIdx] - pIdx)%26+26)%26; if (k[r]===null){ k[r]=val; changed=true; } else if (k[r]!==val){ return false; } }
                  if (pMap[cIdx]!==null && k[r]!==null){ if ( ((pMap[cIdx] - pIdx)%26+26)%26 !== k[r]) return false; }
                }
                const seen=new Set();
                for (let i=0;i<26;i++){ const v=pMap[i]; if (v===null) continue; if (seen.has(v)) return false; seen.add(v); }
              }
              return true;
            }
            function dfs(){
              if (!propagate()) return null;
              if (k.every(v=>v!==null)) return {p:pMap.slice(), k:k.slice()};
              const counts = new Array(m).fill(0); cons.forEach(({r})=>counts[r]++);
              let rr=-1, best=-1; for (let r=0;r<m;r++){ if (k[r]===null && counts[r]>best){best=counts[r]; rr=r;} }
              if (rr<0) return {p:pMap.slice(), k:k.slice()};
              let cand=null; for (const {r,cIdx,pIdx} of cons){ if (r===rr && pMap[cIdx]!==null){ cand = [ ((pMap[cIdx] - pIdx)%26+26)%26 ]; break; } }
              if (!cand) cand=[...Array(26).keys()];
              for (const val of cand){ const old=k[rr]; k[rr]=val; const res=dfs(); if (res) return res; k[rr]=old; }
              return null;
            }
            const sol = dfs();
            if (sol){
              const P = fillPerm(sol.p);
              const dec=[]; for (let i=0;i<cLetters.length;i++){ const c=A2I[cLetters[i]]; dec.push( A[ ((P[c]-sol.k[i % m])%26+26)%26 ] ); }
              results.push({m, key:sol.k, cipherNorm:P, plaintext:dec.join('')});
            }
          }
          return results;
        }
        function cribLetterAt(cribMap, pos){
          if (!cribMap) return null;
          const raw = cribMap[pos];
          if (!raw) return null;
          const up = sanitize(typeof raw === 'string' ? raw : String(raw));
          return up.length ? up[0] : null;
        }
        function findNextCribSegment(stepToAbs, cribMap, endStep){
          if (!Array.isArray(stepToAbs)) return [];
          for (let step = endStep + 1; step < stepToAbs.length; step++){
            const abs = stepToAbs[step];
            if (abs == null || abs < 0) continue;
            const letter = cribLetterAt(cribMap, abs);
            if (!letter) continue;
            const segment = [];
            let pos = step;
            while (pos < stepToAbs.length){
              const absIdx = stepToAbs[pos];
              if (absIdx == null || absIdx < 0) break;
              const nextLetter = cribLetterAt(cribMap, absIdx);
              if (!nextLetter) break;
              segment.push({ step: pos, abs: absIdx, letter: nextLetter });
              pos++;
            }
            return segment;
          }
          return [];
        }
        function matchesNextSegment(text, segment){
          if (!segment || !segment.length) return true;
          for (const item of segment){
            const ch = (text[item.abs] || '').toUpperCase();
            if (ch !== item.letter) return false;
          }
          return true;
        }
        function runBruteForce(msg){
          __cancelled = false;
          const letters = Array.isArray(msg.letters) ? msg.letters : [];
          const wordlist = Array.isArray(msg.wordlist) ? msg.wordlist : [];
          const startPos = msg.startPos|0;
          const endPos = msg.endPos|0;
          const selectionLength = msg.selectionLength|0;
          const minK = msg.minK|0;
          const maxK = msg.maxK|0;
          const op = msg.op || 'vigenere';
          const autokeyAlgo = op === 'autokey_custom_alpha' ? normalizeAutokeyAlgo(msg.autokeyAlgo) : null;
          const maxResults = msg.maxResults|0;
          const quickTrials = Number.isFinite(msg.quickTrials) ? Math.max(0, msg.quickTrials|0) : 30;
          const trialDepth = Number.isFinite(msg.trialDepth) ? Math.max(0, msg.trialDepth|0) : 3;
          const perWordTimeoutRaw = Number.isFinite(msg.wordTimeoutMs) ? msg.wordTimeoutMs : 0;
          const perWordTimeoutMs = perWordTimeoutRaw > 0 ? Math.floor(perWordTimeoutRaw) : 0;
          const quickOpts = { propagateOnly: true, quickTrials, trialDepth };
          const cribPairs = Array.isArray(msg.cribPairs) ? msg.cribPairs : [];
          const cribMap = {};
          for (const pair of cribPairs){
            if (!pair || pair.length < 2) continue;
            const pos = pair[0];
            const letter = pair[1];
            if (typeof pos !== 'number') continue;
            const up = (letter || '').toString().toUpperCase().replace(/[^A-Z]/g,'');
            if (up) cribMap[pos|0] = up[0];
          }
          const { cLetters, absToLetterStep } = buildLetterStreams(letters);
          const stepToAbs = new Array(cLetters.length).fill(-1);
          for (let i=0; i<absToLetterStep.length; i++){ const step = absToLetterStep[i]; if (step >= 0) stepToAbs[step] = i; }
          const existingCribs = collectContiguousCribs(letters, cribMap);
          const selLen = selectionLength > 0 ? selectionLength : (endPos - startPos + 1);
          const cipherSeg = cLetters.slice(startPos, endPos + 1).join('');
          const totalWords = wordlist.length;
          let wordsChecked = 0;
          let wordsSkipped = msg.preSkipped|0;
          let wordsTimedOut = 0;
          const results = [];
          const progressTotal = Math.max(1, totalWords);
          const getTime = (typeof performance !== 'undefined' && typeof performance.now === 'function')
            ? () => performance.now()
            : () => Date.now();
          const progressMod = (function(len){
            if (len >= 1000) return 100;
            if (len >= 200) return 25;
            if (len >= 50) return 10;
            return 1;
          })(totalWords);
          let lastProgressAt = getTime();
          const shouldReport = (idx) => {
            let report = false;
            if (progressMod === 1) report = true;
            else if (idx === 0 || idx === wordlist.length - 1) report = true;
            else if (((idx + 1) % progressMod) === 0) report = true;
            if (!report){
              const now = getTime();
              if (now - lastProgressAt >= 750){
                report = true;
              }
            }
            if (report){
              lastProgressAt = getTime();
            }
            return report;
          };
          postMessage({ kind:'brute_progress', done:0, total: progressTotal, checked:wordsChecked, skipped:wordsSkipped, processed:0, timedOut: wordsTimedOut });
          lastProgressAt = getTime();
          const minKVal = Number.isFinite(minK) && minK > 0 ? minK : 1;
          const maxKVal = Number.isFinite(maxK) && maxK >= minKVal ? maxK : minKVal;
          const enforceNext = !!msg.bridgeNext;
          const nextSegment = enforceNext ? findNextCribSegment(stepToAbs, cribMap, endPos) : [];
          const nextSegmentLen = nextSegment.length;
          for (let idx=0; idx<wordlist.length && !__cancelled; idx++){
            const raw = wordlist[idx];
            const word = sanitize(raw || '');
            if (!word || word.length !== selLen){
              wordsSkipped++;
              if (shouldReport(idx)){
                const processed = idx + 1;
                postMessage({ kind:'brute_progress', done: processed, total: progressTotal, checked:wordsChecked, skipped:wordsSkipped, processed, timedOut: wordsTimedOut });
              }
              continue;
            }
            wordsChecked++;
            let wordTimedOut = false;
            if (op === 'vig_custom_alpha' || op === 'autokey_custom_alpha'){
              const candidateCribMap = Object.assign({}, cribMap);
              let conflict = false;
              for (let t=0; t<word.length; t++){
                const letterStep = startPos + t;
                const absPos = stepToAbs[letterStep];
                if (absPos != null && absPos >= 0 && isLetter(letters[absPos])){
                  const up = word[t];
                  if (candidateCribMap[absPos] && candidateCribMap[absPos] !== up){ conflict = true; break; }
                  candidateCribMap[absPos] = up;
                }
              }
              if (!conflict){
                const wordDeadline = (op === 'autokey_custom_alpha' && perWordTimeoutMs > 0) ? (getTime() + perWordTimeoutMs) : null;
                const plausible = [];
                for (let kk=minKVal; kk<=maxKVal && !__cancelled; kk++){
                  if (wordTimedOut) break;
                  try {
                    if (op === 'vig_custom_alpha'){
                      const quick = solveVigUnknownAlphabet(letters, candidateCribMap, kk, quickOpts);
                      if (quick){
                        plausible.push(kk);
                      }
                    } else {
                      let remainingQuick = null;
                      if (wordDeadline !== null){
                        remainingQuick = wordDeadline - getTime();
                        if (remainingQuick <= 0){
                          wordTimedOut = true;
                          break;
                        }
                      }
                      const quickOptions = Object.assign({}, quickOpts);
                      if (wordDeadline !== null){
                        const maxForQuick = Math.max(1, Math.floor(remainingQuick));
                        quickOptions.maxMillis = maxForQuick;
                      } else if (perWordTimeoutMs > 0){
                        quickOptions.maxMillis = perWordTimeoutMs;
                      }
                      const quick = solveAutokeyUnknownAlphabet(letters, candidateCribMap, kk, quickOptions, autokeyAlgo);
                      if (quickOptions && quickOptions.timedOut){
                        wordTimedOut = true;
                        break;
                      }
                      if (quick){
                        plausible.push(kk);
                      }
                    }
                  } catch(e){}
                }
                if (!wordTimedOut && plausible.length){
                  for (const kk of plausible){
                    if (__cancelled || wordTimedOut) break;
                    if (wordDeadline !== null && getTime() >= wordDeadline){
                      wordTimedOut = true;
                      break;
                    }
                    try {
                      if (op === 'vig_custom_alpha'){
                        const sol = solveVigUnknownAlphabet(letters, candidateCribMap, kk);
                        if (!sol || !sol.pos || !sol.k) continue;
                        const fullDec = decryptWithCustomAlphabet(letters, sol.pos, sol.k);
                        if (enforceNext && nextSegmentLen > 0 && !matchesNextSegment(fullDec, nextSegment)) continue;
                        const decLetters = sanitize(fullDec).split('');
                        const fitness = englishFitness(decLetters);
                        const alphaInfo = buildAlphabetString(sol.pos);
                        const inv = alphaInfo.inv;
                        const keyResidues = sol.k.map(x=>A[x]).join('');
                        const actualKey = sol.k.map(v => inv[v] || '?').join('');
                        results.push({
                          word,
                          keyLength: kk,
                          key: keyResidues,
                          actualKey,
                          alphabet: alphaInfo.invString,
                          decrypted: fullDec,
                          fitness,
                          op: 'vig_custom_alpha'
                        });
                      } else {
                        const solveOpts = {};
                        if (perWordTimeoutMs > 0){
                          const remainingRaw = wordDeadline !== null ? (wordDeadline - getTime()) : perWordTimeoutMs;
                          if (remainingRaw <= 0){
                            wordTimedOut = true;
                            break;
                          }
                          const remaining = Math.max(1, Math.floor(remainingRaw));
                          solveOpts.maxMillis = remaining;
                        }
                        const sol = solveAutokeyUnknownAlphabet(letters, candidateCribMap, kk, solveOpts, autokeyAlgo);
                        if (solveOpts && solveOpts.timedOut){
                          wordTimedOut = true;
                          break;
                        }
                        if (!sol || !sol.pos || !sol.k) continue;
                        const fullDec = decryptAutokeyUnknownAlphabet(letters, sol.pos, sol.k, autokeyAlgo);
                        if (enforceNext && nextSegmentLen > 0 && !matchesNextSegment(fullDec, nextSegment)) continue;
                        const decLetters = sanitize(fullDec).split('');
                        const fitness = englishFitness(decLetters);
                        const alphaInfo = buildAlphabetString(sol.pos);
                        const inv = alphaInfo.inv;
                        const keyResidues = sol.k.map(x=>A[x]).join('');
                        const actualKey = sol.k.map(v => inv[v] || '?').join('');
                        results.push({
                          word,
                          keyLength: kk,
                          key: keyResidues,
                          actualKey,
                          alphabet: alphaInfo.invString,
                          decrypted: fullDec,
                          fitness,
                          op: 'autokey_custom_alpha',
                          autokeyAlgo: autokeyAlgo
                        });
                      }
                    } catch(e){}
                  }
                }
              }
            } else {
              for (let k=minKVal; k<=maxKVal && !__cancelled; k++){
                if (op === 'vigenere'){
                  const res = solveCribVigenere(cipherSeg, word, k, startPos);
                  if (!res.ok) continue;
                  let consistent = true;
                  for (const existing of existingCribs){
                    let letterIdx = -1;
                    for (let i=0, seen=0; i<letters.length; i++){
                      if (isLetter(letters[i])){
                        if (i === existing.start){ letterIdx = seen; break; }
                        seen++;
                      }
                    }
                    if (letterIdx >= 0){
                      const check = solveCribVigenere(existing.cipherSeg, existing.plainSeg, k, letterIdx);
                      if (!check.ok){ consistent = false; break; }
                    }
                  }
                  if (!consistent) continue;
                  const decrypted = applyVigenereDecrypt(letters, res.template);
                  if (enforceNext && nextSegmentLen > 0 && !matchesNextSegment(decrypted, nextSegment)) continue;
                  const decLetters = sanitize(decrypted).split('');
                  const fitness = englishFitness(decLetters);
                  results.push({
                    word,
                    keyLength: k,
                    key: res.template.map(x => x===null ? '?' : A[x]).join(''),
                    decrypted,
                    fitness,
                    op: 'vigenere'
                  });
                } else if (op === 'vig_sub' || op === 'vig_sub_post'){
                  const constraints = [];
                  for (let t=0; t<word.length; t++){
                    constraints.push({
                      pos: startPos + t,
                      cIdx: A2I[cipherSeg[t]],
                      pIdx: A2I[word[t]]
                    });
                  }
                  for (const existing of existingCribs){
                    let letterIdx = -1;
                    for (let i=0, seen=0; i<letters.length; i++){
                      if (isLetter(letters[i])){
                        if (i === existing.start){ letterIdx = seen; break; }
                        seen++;
                      }
                    }
                    if (letterIdx >= 0){
                      for (let t=0; t<existing.cipherSeg.length; t++){
                        const pos = letterIdx + t;
                        constraints.push({ pos, cIdx: A2I[existing.cipherSeg[t]], pIdx: A2I[existing.plainSeg[t]] });
                      }
                    }
                  }
                  if (op === 'vig_sub'){
                    const det = solveMASVigDeterministic(cLetters, constraints, k, k);
                    if (det.length){
                      const r = det[0];
                      let outFull=''; let kpos=0;
                      for (let i=0;i<letters.length;i++){
                        const ch=letters[i];
                        if (!isLetter(ch)){ outFull+=ch; }
                        else { outFull+= r.plaintext[kpos++] || '?'; }
                      }
                      if (enforceNext && nextSegmentLen > 0 && !matchesNextSegment(outFull, nextSegment)) continue;
                      const decLetters = sanitize(outFull).split('');
                      const fitness = englishFitness(decLetters);
                      results.push({
                        word,
                        keyLength: k,
                        key: r.key.map(v=>A[v]).join(''),
                        decrypted: outFull,
                        fitness,
                        op: 'vig_sub'
                      });
                    }
                  } else {
                    const det = solveCipherSubDeterministic(cLetters, constraints, k, k);
                    if (det.length){
                      const r = det[0];
                      let outFull=''; let kpos=0;
                      for (let i=0;i<letters.length;i++){
                        const ch=letters[i];
                        if (!isLetter(ch)){ outFull+=ch; }
                        else { outFull+= r.plaintext[kpos++] || '?'; }
                      }
                      if (enforceNext && nextSegmentLen > 0 && !matchesNextSegment(outFull, nextSegment)) continue;
                      const decLetters = sanitize(outFull).split('');
                      const fitness = englishFitness(decLetters);
                      results.push({
                        word,
                        keyLength: k,
                        key: r.key.map(v=>A[v]).join(''),
                        decrypted: outFull,
                        fitness,
                        op: 'vig_sub_post'
                      });
                    }
                  }
                }
              }
            }
            if (wordTimedOut){
              wordsTimedOut++;
            }
            if (shouldReport(idx)){
              const processed = idx + 1;
              postMessage({ kind:'brute_progress', done: processed, total: progressTotal, checked:wordsChecked, skipped:wordsSkipped, processed, timedOut: wordsTimedOut });
            }
          }
          results.sort((a,b)=> (isFinite(b.fitness)?b.fitness:-Infinity) - (isFinite(a.fitness)?a.fitness:-Infinity));
          const limited = (maxResults && maxResults > 0) ? results.slice(0, maxResults) : results.slice();
          postMessage({ kind:'brute_done', results: limited, totalCandidates: results.length, wordsChecked, wordsSkipped, startPos, endPos, maxResults, cancelled: __cancelled, bridgeNext: enforceNext, nextSegmentLen, wordsTimedOut, autokeyAlgo });
        }
        onmessage = (ev)=>{
          const msg = ev.data||{};
          if (msg && msg.cmd === 'cancel'){
            __cancelled = true;
            try { close(); } catch(e){}
            return;
          }
          if (msg && msg.cmd === 'bruteforce'){
            runBruteForce(msg);
            return;
          }
          if (msg && msg.cmd === 'start'){
            __cancelled = false;
            __candsFound = 0;
            const op = msg.op || 'vig_custom_alpha';
            const letters = msg.letters || [];
            const cribMap = {}; for (const pair of (msg.cribPairs||[])){ if (pair && pair.length >= 2) cribMap[pair[0]] = pair[1]; }
            const minK = msg.minK|0, maxK = msg.maxK|0;
            const autokeyAlgo = normalizeAutokeyAlgo(msg.autokeyAlgo);
            const total = Math.max(1, maxK - minK + 1);
            postMessage({ kind:'progress', done:0, total, label:'m='+minK, candidatesFound: __candsFound });
            const results=[];
            for (let m=minK; m<=maxK && !__cancelled; m++){
              if (op === 'autokey_custom_alpha'){
                const sol = solveAutokeyUnknownAlphabet(letters, cribMap, m, undefined, autokeyAlgo);
                if (sol){
                  const dec = decryptAutokeyUnknownAlphabet(letters, sol.pos, sol.k, autokeyAlgo);
                  const fit = englishFitness(dec.toUpperCase().replace(/[^A-Z]/g,'').split(''));
                  __candsFound++;
                  const alphaInfo = buildAlphabetString(sol.pos);
                  const keyResidues = sol.k.map(v=>String.fromCharCode(65+v)).join('');
                  const actualKey = sol.k.map(v => alphaInfo.inv[v] || '?').join('');
                  const cand = {
                    keyLength:m,
                    key: keyResidues,
                    actualKey,
                    alphabet: alphaInfo.invString,
                    posRaw: sol.pos,
                    kRaw: sol.k,
                    score: fit,
                    preview: dec.slice(0,200),
                    full: dec,
                    autokeyAlgo
                  };
                  results.push(cand);
                  postMessage({ kind:'candidate', ...cand });
                }
              } else {
                const sol = solveVigUnknownAlphabet(letters, cribMap, m, (p)=>postMessage({kind:'hint', m, p}));
                if (sol){
                  const dec = decryptWithCustomAlphabet(letters, sol.pos, sol.k);
                  const fit = englishFitness(dec.toUpperCase().replace(/[^A-Z]/g,'').split(''));
                  __candsFound++;
                  const keyResidues = sol.k.map(v=>String.fromCharCode(65+v)).join('');
                  results.push({ keyLength:m, key: keyResidues, actualKey: null, posRaw: sol.pos, kRaw: sol.k, score: fit, preview: dec.slice(0,200), full: dec });
                }
              }
              postMessage({ kind:'progress', done:(m - minK + 1), total, label:'m='+m, candidatesFound: __candsFound });
            }
            if (__cancelled){
              postMessage({ kind:'done', cancelled:true, results });
            } else {
              results.sort((a,b)=>b.score-a.score);
              postMessage({kind:'done', op, results, autokeyAlgo });
            }
          }
        };
      `;
      return new Worker(URL.createObjectURL(new Blob([src], {type:"application/javascript"})));
    }

    function resetStop(){
      if (BTN_STOP){
        BTN_STOP.disabled = true;
      }
    }

    function updateStopVisibility(){
      updateAutokeyAlgoVisibility();
      if (!BTN_STOP) return;
      BTN_STOP.style.display = 'inline-block';
      BTN_STOP.disabled = !currentJob;
    }

    function stopWorker(summaryText, outText){
      clearAutoStopTimer();
      if (uaWorker){
        try { uaWorker.postMessage({cmd:'cancel'}); } catch(e){}
        try { uaWorker.terminate(); } catch(e){}
        uaWorker = null;
      }
      hideProgress();
      if (currentJob === 'brute'){
        if (BTN_BRUTE) BTN_BRUTE.disabled = false;
        if (BRUTE_PANEL) BRUTE_PANEL.style.display = 'block';
        if (typeof summaryText === 'string' && BRUTE_SUMMARY) BRUTE_SUMMARY.textContent = summaryText;
        if (typeof outText === 'string' && BRUTE_OUT) BRUTE_OUT.textContent = outText;
      } else {
        if (BTN_TEST) BTN_TEST.disabled = false;
        if (typeof summaryText === 'string' && SUMMARY) setSummaryMessage(summaryText);
        if (typeof outText === 'string' && OUT) OUT.textContent = outText;
      }
      updateHeatMeter(null);
      currentJob = null;
      bruteCtx = null;
      resetStop();
      updateStopVisibility();
    }

    function startWorkerSolve(){
      const payload = gatherForWorker();
      if (!payload.cribPairs.length){
        if (SUMMARY) setSummaryMessage('Enter at least one crib segment first.');
        return;
      }
      const isAutokey = payload.op === 'autokey_custom_alpha';
      const modeLabel = isAutokey
        ? `autokey (${autokeyAlgoLabel(payload.autokeyAlgo)}) + unknown alphabet`
        : 'unknown alphabet Vigenère';

      currentJob = 'unknown';
      bruteCtx = null;

      if (BTN_TEST) BTN_TEST.disabled = true;
      if (BTN_STOP){
        BTN_STOP.disabled = false;
      }
      updateStopVisibility();
      if (SUMMARY) setSummaryMessage(`Running ${modeLabel}…`);
      if (OUT) OUT.textContent = '';
      if (CAND_CNT) CAND_CNT.textContent = '0';
      showProgress(1);
      scheduleAutoStop();

      if (uaWorker){ try { uaWorker.terminate(); } catch(e){} }
      uaWorker = makeWorker();

      const streamed = [];
      let initializedTotal = false;
      let dynTotal = 0;
      let nodeSeen = 0;

      uaWorker.onmessage = (ev) => {
        const data = ev && ev.data ? ev.data : {};
        if (data && typeof data.candidatesFound === 'number' && CAND_CNT){
          CAND_CNT.textContent = String(data.candidatesFound);
        }
        const kind = data.type || data.kind || data.event;
        if (kind === 'progress' || kind === 'hint'){
          if ('total' in data && 'done' in data){
            const panel = ensureProgressPanel();
            const totalNum = Math.max(1, data.total|0);
            const currentTotal = parseInt(panel.dataset.total || '0');
            if (!initializedTotal || currentTotal !== totalNum){
              showProgress(totalNum);
              initializedTotal = true;
            }
            updateProgress(data.done|0);
            return;
          }
          const dfs = data.p && data.p.kind === 'dfs' ? data.p : (kind === 'dfs' ? data : null);
          if (dfs && typeof dfs.nodes === 'number'){
            nodeSeen = dfs.nodes|0;
            if (dynTotal < nodeSeen + 100) dynTotal = nodeSeen + 1000;
            const panel = ensureProgressPanel();
            const currentTotal = parseInt(panel.dataset.total || '0');
            if (!initializedTotal || currentTotal !== dynTotal){
              showProgress(dynTotal);
              initializedTotal = true;
            }
            updateProgress(nodeSeen);
            return;
          }
        }
        if (kind === 'candidate'){
          streamed.push(data);
          return;
        }
        if (kind === 'result' || kind === 'done'){
          clearAutoStopTimer();
          hideProgress();
          if (BTN_STOP){
            BTN_STOP.disabled = true;
          }
          if (BTN_TEST) BTN_TEST.disabled = false;
          try { uaWorker.terminate(); } catch(e){}
          uaWorker = null;
          currentJob = null;
          updateStopVisibility();

          const baseResults = Array.isArray(data.results) && data.results.length ? data.results : streamed;
          if (!baseResults.length){
            if (SUMMARY){
              const idx = Math.floor(Math.random() * NO_RESULT_MESSAGES.length);
              setSummaryMessage(NO_RESULT_MESSAGES[idx] || 'No luck this time — give it another whirl!', { noResult: true });
            }
            if (OUT) OUT.textContent = '';
            updateHeatMeter(null);
            return;
          }
          baseResults.sort((a,b)=> (b.score||0) - (a.score||0));
          const best = baseResults[0];
          if (!best){
            if (SUMMARY) setSummaryMessage('We searched the range but did not land on a readable decrypt.', { noResult: true });
            if (OUT) OUT.textContent = '';
            updateHeatMeter(null);
            return;
          }
          if (OUT){
            OUT.textContent = best.full || '';
          }
          const stats = computeEnglishStats(best.full || '');
          const scored = updateHeatMeter(stats);
          if (SUMMARY){
            const pct = Math.round((scored.score || 0) * 100);
            let mood;
            if (pct >= 90) mood = '🔥 Blazing! That reads like a solved mystery.';
            else if (pct >= 65) mood = '🌶️ Spicy! The plaintext is almost unlocked.';
            else if (pct >= 40) mood = '✨ Warming up — a few tweaks might crack it.';
            else if (pct > 0) mood = '🧊 Still chilly. Try sprinkling in more crib letters.';
            else mood = 'Add a few more confident letters so the meter can take a proper reading.';
            setSummaryMessage(`Key length ${best.keyLength}: ${mood} (${pct}% hot)`);
          }
        }
      };

      uaWorker.onerror = (e) => {
        const msg = e && (e.message || e.toString()) || 'unknown error';
        stopWorker('Worker error (stopped).', 'Worker error: ' + msg);
      };

      uaWorker.postMessage({ cmd:'start', ...payload });
    }

    function startBruteWorker(payload){
      if (!payload || !Array.isArray(payload.wordlist)){
        return;
      }

      const totalWords = Array.isArray(payload.wordlist) ? payload.wordlist.length : 0;
      const skippedPre = payload.preSkipped|0;

      if (!totalWords){
        if (BRUTE_PANEL) BRUTE_PANEL.style.display = 'block';
        if (BRUTE_SUMMARY){
          let text = `No candidate words to test (skipped ${skippedPre} wrong-length).`;
          if (payload.bridgeNext){
            text += ' Enforce-next-crib requested.';
          }
          BRUTE_SUMMARY.textContent = text;
        }
        return;
      }

      currentJob = 'brute';
      bruteCtx = {
        startPos: payload.startPos|0,
        endPos: payload.endPos|0,
        maxResults: payload.maxResults,
        skippedPre,
        totalWords,
        bridgeNext: !!payload.bridgeNext,
        autokeyAlgo: payload.op === 'autokey_custom_alpha' ? normalizeAutokeyAlgo(payload.autokeyAlgo) : null
      };

      if (BTN_BRUTE) BTN_BRUTE.disabled = true;
      if (BTN_STOP){
        BTN_STOP.disabled = false;
      }
      updateStopVisibility();
      if (BRUTE_PANEL) BRUTE_PANEL.style.display = 'block';
      if (BRUTE_OUT) BRUTE_OUT.innerHTML = '';
      if (BRUTE_SUMMARY){
        let text = `Running brute force on ${totalWords.toLocaleString()} word(s) (skipped ${skippedPre.toLocaleString()} wrong-length).`;
        if (payload.bridgeNext){
          text += ' Enforcing next crib segment.';
        }
        if (payload.op === 'autokey_custom_alpha'){
          const variantLabel = autokeyAlgoLabel(normalizeAutokeyAlgo(payload.autokeyAlgo));
          text += ` Autokey variant: ${variantLabel}.`;
        }
        BRUTE_SUMMARY.textContent = text;
      }

      showProgress(Math.max(1, totalWords));

      if (uaWorker){ try { uaWorker.terminate(); } catch(e){} }
      uaWorker = makeWorker();

      let progressInitialized = false;

      uaWorker.onmessage = (ev) => {
        const data = ev && ev.data ? ev.data : {};
        const kind = data.kind || data.type || data.event;
        if (kind === 'brute_progress'){
          const total = Math.max(1, data.total|0);
          if (!progressInitialized){
            showProgress(total);
            progressInitialized = true;
          }
          const done = data.done|0;
          const checked = data.checked|0;
          const skipped = data.skipped|0;
          const timedOut = typeof data.timedOut === 'number' ? data.timedOut|0 : 0;
          const processed = typeof data.processed === 'number' ? data.processed|0 : Math.max(done, checked + skipped);
          updateProgress(done);
          if (BRUTE_SUMMARY){
            const timeoutPart = timedOut > 0 ? `, timed out ${timedOut.toLocaleString()}` : '';
            let text = `Processed ${processed.toLocaleString()} / ${total.toLocaleString()} words — checked ${checked.toLocaleString()} (skipped ${skipped.toLocaleString()}${timeoutPart}).`;
            if (bruteCtx && bruteCtx.bridgeNext){
              text += ' Enforcing next crib segment.';
            }
            if (bruteCtx && bruteCtx.autokeyAlgo){
              text += ` Autokey variant: ${autokeyAlgoLabel(bruteCtx.autokeyAlgo)}.`;
            }
            BRUTE_SUMMARY.textContent = text;
          }
          return;
        }
        if (kind === 'brute_done'){
          hideProgress();
          if (BTN_STOP){
            BTN_STOP.disabled = true;
          }
          if (BTN_BRUTE) BTN_BRUTE.disabled = false;
          try { uaWorker.terminate(); } catch(e){}
          uaWorker = null;

          const wordsChecked = data.wordsChecked|0;
          const wordsSkipped = data.wordsSkipped|0;
          const totalCandidates = typeof data.totalCandidates === 'number' ? data.totalCandidates : (Array.isArray(data.results) ? data.results.length : 0);
          const results = Array.isArray(data.results) ? data.results : [];

          displayBruteResults(
            results,
            data.startPos,
            data.endPos,
            wordsChecked,
            wordsSkipped,
            totalCandidates,
            data.maxResults,
            { bridgeNext: !!data.bridgeNext, nextSegmentLen: typeof data.nextSegmentLen === 'number' ? data.nextSegmentLen : undefined, timedOutWords: typeof data.wordsTimedOut === 'number' ? data.wordsTimedOut|0 : 0, autokeyAlgo: data.autokeyAlgo }
          );
          if (data.cancelled && BRUTE_SUMMARY){
            BRUTE_SUMMARY.textContent += ' (stopped early)';
          }

          currentJob = null;
          bruteCtx = null;
          updateStopVisibility();
          return;
        }
      };

      uaWorker.onerror = (e) => {
        const msg = e && (e.message || e.toString()) || 'unknown error';
        stopWorker('Brute force worker error: ' + msg);
      };

      uaWorker.postMessage({ cmd:'bruteforce', ...payload });
    }

    if (BTN_STOP){
      BTN_STOP.addEventListener('click', (ev)=>{
        ev.preventDefault();
        const msg = currentJob === 'brute' ? 'Brute force cancelled.' : 'Search cancelled.';
        stopWorker(msg);
      });
    }

    if (BTN_TEST){
      BTN_TEST.addEventListener('click', (ev)=>{
        const op = SEL_OP ? SEL_OP.value : '';
        if (op === 'vig_custom_alpha' || op === 'autokey_custom_alpha'){
          ev.preventDefault();
          ev.stopImmediatePropagation();
          startWorkerSolve();
        }
      }, true);
    }

    if (SEL_OP){
      SEL_OP.addEventListener('change', () => {
        updateStopVisibility();
      });
      updateStopVisibility();
    } else {
      resetStop();
      updateAutokeyAlgoVisibility();
    }

    if (typeof window !== 'undefined'){
      window.__startBruteWorker = startBruteWorker;
    }
  })();
  </script>

</body>
</html>
